============================================================
FILE: .\main.py
============================================================

from fastapi import FastAPI, Request
from fastapi.responses import JSONResponse
from fastapi.middleware.cors import CORSMiddleware
import logging
import uvicorn
from contextlib import asynccontextmanager
import os

from routes.auth_routes import router as auth_router

# Load environment variables
HOST = os.getenv('HOST', '0.0.0.0')
PORT = int(os.getenv('PORT', '8000'))
RELOAD = os.getenv('RELOAD', 'True').lower() == 'true'
LOG_LEVEL = os.getenv('LOG_LEVEL', 'info')
ENVIRONMENT = os.getenv('ENVIRONMENT', 'development')

# CORS origins from environment
CORS_ORIGINS = os.getenv('CORS_ORIGINS', 'http://localhost:3000,http://127.0.0.1:3000')
ALLOWED_ORIGINS = [origin.strip() for origin in CORS_ORIGINS.split(',')]

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler('auth_service.log')
    ]
)

logger = logging.getLogger(__name__)

@asynccontextmanager
async def lifespan(app: FastAPI):
    logger.info("Starting Authentication Service...")
    logger.info(f"Environment: {ENVIRONMENT}")
    logger.info(f"Host: {HOST}, Port: {PORT}")
    
    yield
    
    logger.info("Shutting down Authentication Service...")
    logger.info("Service is shutting down")

app = FastAPI(
    title="Ecommerce API - Authentication Service",
    description="Authentication microservice for Ecommerce API",
    version="1.0.0",
    docs_url="/docs",
    redoc_url="/redoc",
    openapi_url="/openapi.json",
    lifespan=lifespan
)

app.add_middleware(
    CORSMiddleware,
    allow_origins=ALLOWED_ORIGINS,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

@app.exception_handler(Exception)
async def global_exception_handler(request: Request, exc: Exception):
    logger.error(f"Global exception handler: {str(exc)}", exc_info=True)
    return JSONResponse(
        status_code=500,
        content={
            "type": "https://example.com/errors/internal",
            "title": "Internal Server Error",
            "status": 500,
            "detail": "An unexpected error occurred",
            "instance": str(request.url)
        },
        media_type="application/problem+json"
    )

@app.get("/health", tags=["Health"])
async def health_check():
    """Health check endpoint for service monitoring"""
    return {
        "status": "healthy",
        "service": "authentication",
        "timestamp": "2024-01-01T00:00:00Z",
        "environment": ENVIRONMENT
    }

@app.get("/", tags=["Root"])
async def root():
    """Root endpoint with service information"""
    return {
        "message": "Ecommerce Authentication Service",
        "version": "1.0.0",
        "environment": ENVIRONMENT,
        "docs": "/docs",
        "health": "/health"
    }

app.include_router(auth_router, prefix="/api")

if __name__ == "__main__":
    uvicorn.run(
        "main:app",
        host=HOST,
        port=PORT,
        reload=RELOAD,
        log_level=LOG_LEVEL
    )

============================================================
FILE: .\project_bundle.txt
============================================================

Project Bundle - 2025-11-23 14:15:26.959521


============================================================
FILE: .\.coverage
============================================================


============================================================
FILE: .\auth_service.log
============================================================

2025-11-22 23:47:33,300 - main - INFO - Starting Authentication Service...
2025-11-22 23:47:33,300 - main - INFO - Service is starting up
2025-11-22 23:56:27,019 - main - INFO - Shutting down Authentication Service...
2025-11-22 23:56:27,019 - main - INFO - Service is shutting down
2025-11-22 23:56:27,515 - main - INFO - Starting Authentication Service...
2025-11-22 23:56:27,516 - main - INFO - Service is starting up
2025-11-22 23:56:30,076 - main - INFO - Shutting down Authentication Service...
2025-11-22 23:56:30,076 - main - INFO - Service is shutting down
2025-11-22 23:56:30,555 - main - INFO - Starting Authentication Service...
2025-11-22 23:56:30,555 - main - INFO - Service is starting up
2025-11-22 23:56:34,723 - main - INFO - Shutting down Authentication Service...
2025-11-22 23:56:34,723 - main - INFO - Service is shutting down
2025-11-22 23:56:35,177 - main - INFO - Starting Authentication Service...
2025-11-22 23:56:35,177 - main - INFO - Service is starting up
2025-11-22 23:56:37,275 - main - INFO - Shutting down Authentication Service...
2025-11-22 23:56:37,275 - main - INFO - Service is shutting down
2025-11-22 23:56:37,731 - main - INFO - Starting Authentication Service...
2025-11-22 23:56:37,732 - main - INFO - Service is starting up
2025-11-22 23:56:47,496 - main - INFO - Shutting down Authentication Service...
2025-11-22 23:56:47,496 - main - INFO - Service is shutting down
2025-11-22 23:56:47,989 - main - INFO - Starting Authentication Service...
2025-11-22 23:56:47,990 - main - INFO - Service is starting up
2025-11-22 23:56:51,415 - main - INFO - Shutting down Authentication Service...
2025-11-22 23:56:51,415 - main - INFO - Service is shutting down
2025-11-22 23:56:51,865 - main - INFO - Starting Authentication Service...
2025-11-22 23:56:51,865 - main - INFO - Service is starting up
2025-11-22 23:56:53,964 - main - INFO - Shutting down Authentication Service...
2025-11-22 23:56:53,964 - main - INFO - Service is shutting down
2025-11-22 23:56:54,421 - main - INFO - Starting Authentication Service...
2025-11-22 23:56:54,422 - main - INFO - Service is starting up
2025-11-22 23:56:56,853 - main - INFO - Shutting down Authentication Service...
2025-11-22 23:56:56,853 - main - INFO - Service is shutting down
2025-11-22 23:56:57,316 - main - INFO - Starting Authentication Service...
2025-11-22 23:56:57,316 - main - INFO - Service is starting up
2025-11-22 23:56:58,882 - main - INFO - Shutting down Authentication Service...
2025-11-22 23:56:58,882 - main - INFO - Service is shutting down
2025-11-22 23:56:59,353 - main - INFO - Starting Authentication Service...
2025-11-22 23:56:59,353 - main - INFO - Service is starting up
2025-11-22 23:57:00,683 - main - INFO - Shutting down Authentication Service...
2025-11-22 23:57:00,684 - main - INFO - Service is shutting down
2025-11-22 23:57:01,148 - main - INFO - Starting Authentication Service...
2025-11-22 23:57:01,148 - main - INFO - Service is starting up
2025-11-22 23:57:03,244 - main - INFO - Shutting down Authentication Service...
2025-11-22 23:57:03,245 - main - INFO - Service is shutting down
2025-11-22 23:57:03,711 - main - INFO - Starting Authentication Service...
2025-11-22 23:57:03,711 - main - INFO - Service is starting up
2025-11-22 23:57:04,495 - main - INFO - Shutting down Authentication Service...
2025-11-22 23:57:04,496 - main - INFO - Service is shutting down
2025-11-22 23:57:04,973 - main - INFO - Starting Authentication Service...
2025-11-22 23:57:04,973 - main - INFO - Service is starting up
2025-11-22 23:57:14,814 - main - INFO - Shutting down Authentication Service...
2025-11-22 23:57:14,814 - main - INFO - Service is shutting down
2025-11-22 23:57:15,274 - main - INFO - Starting Authentication Service...
2025-11-22 23:57:15,274 - main - INFO - Service is starting up
2025-11-22 23:57:17,386 - main - INFO - Shutting down Authentication Service...
2025-11-22 23:57:17,387 - main - INFO - Service is shutting down
2025-11-22 23:57:17,858 - main - INFO - Starting Authentication Service...
2025-11-22 23:57:17,858 - main - INFO - Service is starting up
2025-11-22 23:57:20,282 - main - INFO - Shutting down Authentication Service...
2025-11-22 23:57:20,282 - main - INFO - Service is shutting down
2025-11-22 23:57:20,747 - main - INFO - Starting Authentication Service...
2025-11-22 23:57:20,747 - main - INFO - Service is starting up
2025-11-22 23:57:22,635 - main - INFO - Shutting down Authentication Service...
2025-11-22 23:57:22,635 - main - INFO - Service is shutting down
2025-11-22 23:57:23,136 - main - INFO - Starting Authentication Service...
2025-11-22 23:57:23,137 - main - INFO - Service is starting up
2025-11-22 23:57:24,679 - main - INFO - Shutting down Authentication Service...
2025-11-22 23:57:24,679 - main - INFO - Service is shutting down
2025-11-22 23:57:25,131 - main - INFO - Starting Authentication Service...
2025-11-22 23:57:25,131 - main - INFO - Service is starting up
2025-11-22 23:57:27,018 - main - INFO - Shutting down Authentication Service...
2025-11-22 23:57:27,018 - main - INFO - Service is shutting down
2025-11-22 23:57:27,492 - main - INFO - Starting Authentication Service...
2025-11-22 23:57:27,492 - main - INFO - Service is starting up
2025-11-22 23:57:29,908 - main - INFO - Shutting down Authentication Service...
2025-11-22 23:57:29,908 - main - INFO - Service is shutting down
2025-11-22 23:57:30,411 - main - INFO - Starting Authentication Service...
2025-11-22 23:57:30,412 - main - INFO - Service is starting up
2025-11-22 23:57:32,729 - main - INFO - Shutting down Authentication Service...
2025-11-22 23:57:32,730 - main - INFO - Service is shutting down
2025-11-22 23:57:33,203 - main - INFO - Starting Authentication Service...
2025-11-22 23:57:33,203 - main - INFO - Service is starting up
2025-11-22 23:57:40,633 - main - INFO - Shutting down Authentication Service...
2025-11-22 23:57:40,633 - main - INFO - Service is shutting down
2025-11-22 23:57:41,119 - main - INFO - Starting Authentication Service...
2025-11-22 23:57:41,119 - main - INFO - Service is starting up
2025-11-22 23:57:43,989 - main - INFO - Shutting down Authentication Service...
2025-11-22 23:57:43,989 - main - INFO - Service is shutting down
2025-11-22 23:57:44,503 - main - INFO - Starting Authentication Service...
2025-11-22 23:57:44,503 - main - INFO - Service is starting up
2025-11-22 23:57:46,594 - main - INFO - Shutting down Authentication Service...
2025-11-22 23:57:46,594 - main - INFO - Service is shutting down
2025-11-22 23:57:47,060 - main - INFO - Starting Authentication Service...
2025-11-22 23:57:47,061 - main - INFO - Service is starting up
2025-11-22 23:58:02,367 - main - INFO - Shutting down Authentication Service...
2025-11-22 23:58:02,368 - main - INFO - Service is shutting down
2025-11-22 23:58:02,857 - main - INFO - Starting Authentication Service...
2025-11-22 23:58:02,857 - main - INFO - Service is starting up
2025-11-22 23:58:03,641 - main - INFO - Shutting down Authentication Service...
2025-11-22 23:58:03,641 - main - INFO - Service is shutting down
2025-11-22 23:58:04,096 - main - INFO - Starting Authentication Service...
2025-11-22 23:58:04,096 - main - INFO - Service is starting up
2025-11-22 23:58:08,586 - main - INFO - Shutting down Authentication Service...
2025-11-22 23:58:08,587 - main - INFO - Service is shutting down
2025-11-22 23:58:09,054 - main - INFO - Starting Authentication Service...
2025-11-22 23:58:09,054 - main - INFO - Service is starting up
2025-11-22 23:58:12,821 - main - INFO - Shutting down Authentication Service...
2025-11-22 23:58:12,821 - main - INFO - Service is shutting down
2025-11-22 23:58:13,313 - main - INFO - Starting Authentication Service...
2025-11-22 23:58:13,313 - main - INFO - Service is starting up
2025-11-22 23:58:14,655 - main - INFO - Shutting down Authentication Service...
2025-11-22 23:58:14,655 - main - INFO - Service is shutting down
2025-11-22 23:58:15,155 - main - INFO - Starting Authentication Service...
2025-11-22 23:58:15,156 - main - INFO - Service is starting up
2025-11-22 23:58:19,550 - main - INFO - Shutting down Authentication Service...
2025-11-22 23:58:19,550 - main - INFO - Service is shutting down
2025-11-22 23:58:20,003 - main - INFO - Starting Authentication Service...
2025-11-22 23:58:20,003 - main - INFO - Service is starting up
2025-11-22 23:58:30,510 - main - INFO - Shutting down Authentication Service...
2025-11-22 23:58:30,510 - main - INFO - Service is shutting down
2025-11-22 23:58:30,971 - main - INFO - Starting Authentication Service...
2025-11-22 23:58:30,971 - main - INFO - Service is starting up
2025-11-22 23:58:31,759 - main - INFO - Shutting down Authentication Service...
2025-11-22 23:58:31,760 - main - INFO - Service is shutting down
2025-11-22 23:58:32,232 - main - INFO - Starting Authentication Service...
2025-11-22 23:58:32,232 - main - INFO - Service is starting up
2025-11-22 23:58:34,583 - main - INFO - Shutting down Authentication Service...
2025-11-22 23:58:34,587 - main - INFO - Service is shutting down
2025-11-22 23:58:35,078 - main - INFO - Starting Authentication Service...
2025-11-22 23:58:35,078 - main - INFO - Service is starting up
2025-11-22 23:58:38,272 - main - INFO - Shutting down Authentication Service...
2025-11-22 23:58:38,273 - main - INFO - Service is shutting down
2025-11-22 23:58:38,738 - main - INFO - Starting Authentication Service...
2025-11-22 23:58:38,738 - main - INFO - Service is starting up
2025-11-22 23:58:41,157 - main - INFO - Shutting down Authentication Service...
2025-11-22 23:58:41,157 - main - INFO - Service is shutting down
2025-11-22 23:58:41,638 - main - INFO - Starting Authentication Service...
2025-11-22 23:58:41,638 - main - INFO - Service is starting up
2025-11-22 23:58:42,207 - main - INFO - Shutting down Authentication Service...
2025-11-22 23:58:42,208 - main - INFO - Service is shutting down
2025-11-22 23:58:42,673 - main - INFO - Starting Authentication Service...
2025-11-22 23:58:42,673 - main - INFO - Service is starting up
2025-11-22 23:58:48,721 - main - INFO - Shutting down Authentication Service...
2025-11-22 23:58:48,721 - main - INFO - Service is shutting down
2025-11-22 23:58:49,215 - main - INFO - Starting Authentication Service...
2025-11-22 23:58:49,215 - main - INFO - Service is starting up
2025-11-22 23:58:50,545 - main - INFO - Shutting down Authentication Service...
2025-11-22 23:58:50,545 - main - INFO - Service is shutting down
2025-11-22 23:58:51,009 - main - INFO - Starting Authentication Service...
2025-11-22 23:58:51,010 - main - INFO - Service is starting up
2025-11-22 23:58:57,928 - main - INFO - Shutting down Authentication Service...
2025-11-22 23:58:57,928 - main - INFO - Service is shutting down
2025-11-22 23:58:58,383 - main - INFO - Starting Authentication Service...
2025-11-22 23:58:58,383 - main - INFO - Service is starting up
2025-11-22 23:58:59,705 - main - INFO - Shutting down Authentication Service...
2025-11-22 23:58:59,705 - main - INFO - Service is shutting down
2025-11-22 23:59:00,203 - main - INFO - Starting Authentication Service...
2025-11-22 23:59:00,203 - main - INFO - Service is starting up
2025-11-22 23:59:05,455 - main - INFO - Shutting down Authentication Service...
2025-11-22 23:59:05,455 - main - INFO - Service is shutting down
2025-11-22 23:59:05,953 - main - INFO - Starting Authentication Service...
2025-11-22 23:59:05,954 - main - INFO - Service is starting up
2025-11-23 00:02:49,878 - main - INFO - Shutting down Authentication Service...
2025-11-23 00:02:49,878 - main - INFO - Service is shutting down
2025-11-23 00:02:50,363 - main - INFO - Starting Authentication Service...
2025-11-23 00:02:50,363 - main - INFO - Service is starting up
2025-11-23 00:04:33,276 - main - INFO - Shutting down Authentication Service...
2025-11-23 00:04:33,277 - main - INFO - Service is shutting down
2025-11-23 00:04:33,800 - main - INFO - Starting Authentication Service...
2025-11-23 00:04:33,800 - main - INFO - Service is starting up
2025-11-23 00:04:35,342 - main - INFO - Shutting down Authentication Service...
2025-11-23 00:04:35,342 - main - INFO - Service is shutting down
2025-11-23 00:04:35,839 - main - INFO - Starting Authentication Service...
2025-11-23 00:04:35,839 - main - INFO - Service is starting up
2025-11-23 00:04:37,725 - main - INFO - Shutting down Authentication Service...
2025-11-23 00:04:37,725 - main - INFO - Service is shutting down
2025-11-23 00:04:38,206 - main - INFO - Starting Authentication Service...
2025-11-23 00:04:38,206 - main - INFO - Service is starting up
2025-11-23 00:04:41,388 - main - INFO - Shutting down Authentication Service...
2025-11-23 00:04:41,388 - main - INFO - Service is shutting down
2025-11-23 00:04:41,936 - main - INFO - Starting Authentication Service...
2025-11-23 00:04:41,936 - main - INFO - Service is starting up
2025-11-23 00:04:42,725 - main - INFO - Shutting down Authentication Service...
2025-11-23 00:04:42,725 - main - INFO - Service is shutting down
2025-11-23 00:04:43,209 - main - INFO - Starting Authentication Service...
2025-11-23 00:04:43,210 - main - INFO - Service is starting up
2025-11-23 00:04:44,006 - main - INFO - Shutting down Authentication Service...
2025-11-23 00:04:44,006 - main - INFO - Service is shutting down
2025-11-23 00:04:44,479 - main - INFO - Starting Authentication Service...
2025-11-23 00:04:44,479 - main - INFO - Service is starting up
2025-11-23 00:04:45,055 - main - INFO - Shutting down Authentication Service...
2025-11-23 00:04:45,055 - main - INFO - Service is shutting down
2025-11-23 00:04:45,558 - main - INFO - Starting Authentication Service...
2025-11-23 00:04:45,559 - main - INFO - Service is starting up
2025-11-23 00:04:46,349 - main - INFO - Shutting down Authentication Service...
2025-11-23 00:04:46,349 - main - INFO - Service is shutting down
2025-11-23 00:04:46,861 - main - INFO - Starting Authentication Service...
2025-11-23 00:04:46,862 - main - INFO - Service is starting up
2025-11-23 00:04:47,863 - main - INFO - Shutting down Authentication Service...
2025-11-23 00:04:47,863 - main - INFO - Service is shutting down
2025-11-23 00:04:48,342 - main - INFO - Starting Authentication Service...
2025-11-23 00:04:48,342 - main - INFO - Service is starting up
2025-11-23 00:04:53,819 - main - INFO - Shutting down Authentication Service...
2025-11-23 00:04:53,819 - main - INFO - Service is shutting down
2025-11-23 00:04:54,313 - main - INFO - Starting Authentication Service...
2025-11-23 00:04:54,313 - main - INFO - Service is starting up
2025-11-23 00:05:00,130 - main - INFO - Shutting down Authentication Service...
2025-11-23 00:05:00,130 - main - INFO - Service is shutting down
2025-11-23 00:05:00,620 - main - INFO - Starting Authentication Service...
2025-11-23 00:05:00,620 - main - INFO - Service is starting up
2025-11-23 00:05:03,809 - main - INFO - Shutting down Authentication Service...
2025-11-23 00:05:03,810 - main - INFO - Service is shutting down
2025-11-23 00:05:04,336 - main - INFO - Starting Authentication Service...
2025-11-23 00:05:04,336 - main - INFO - Service is starting up
2025-11-23 00:05:05,124 - main - INFO - Shutting down Authentication Service...
2025-11-23 00:05:05,125 - main - INFO - Service is shutting down
2025-11-23 00:05:05,611 - main - INFO - Starting Authentication Service...
2025-11-23 00:05:05,611 - main - INFO - Service is starting up
2025-11-23 00:05:06,389 - main - INFO - Shutting down Authentication Service...
2025-11-23 00:05:06,389 - main - INFO - Service is shutting down
2025-11-23 00:05:06,850 - main - INFO - Starting Authentication Service...
2025-11-23 00:05:06,851 - main - INFO - Service is starting up
2025-11-23 00:05:07,967 - main - INFO - Shutting down Authentication Service...
2025-11-23 00:05:07,967 - main - INFO - Service is shutting down
2025-11-23 00:05:08,419 - main - INFO - Starting Authentication Service...
2025-11-23 00:05:08,419 - main - INFO - Service is starting up
2025-11-23 00:05:09,970 - main - INFO - Shutting down Authentication Service...
2025-11-23 00:05:09,970 - main - INFO - Service is shutting down
2025-11-23 00:05:10,466 - main - INFO - Starting Authentication Service...
2025-11-23 00:05:10,466 - main - INFO - Service is starting up
2025-11-23 00:05:11,256 - main - INFO - Shutting down Authentication Service...
2025-11-23 00:05:11,256 - main - INFO - Service is shutting down
2025-11-23 00:05:11,708 - main - INFO - Starting Authentication Service...
2025-11-23 00:05:11,708 - main - INFO - Service is starting up
2025-11-23 00:05:13,048 - main - INFO - Shutting down Authentication Service...
2025-11-23 00:05:13,048 - main - INFO - Service is shutting down
2025-11-23 00:05:13,522 - main - INFO - Starting Authentication Service...
2025-11-23 00:05:13,522 - main - INFO - Service is starting up
2025-11-23 00:05:15,939 - main - INFO - Shutting down Authentication Service...
2025-11-23 00:05:15,939 - main - INFO - Service is shutting down
2025-11-23 00:05:16,443 - main - INFO - Starting Authentication Service...
2025-11-23 00:05:16,444 - main - INFO - Service is starting up
2025-11-23 00:05:17,241 - main - INFO - Shutting down Authentication Service...
2025-11-23 00:05:17,241 - main - INFO - Service is shutting down
2025-11-23 00:05:17,714 - main - INFO - Starting Authentication Service...
2025-11-23 00:05:17,714 - main - INFO - Service is starting up
2025-11-23 00:05:20,130 - main - INFO - Shutting down Authentication Service...
2025-11-23 00:05:20,131 - main - INFO - Service is shutting down
2025-11-23 00:05:20,598 - main - INFO - Starting Authentication Service...
2025-11-23 00:05:20,598 - main - INFO - Service is starting up
2025-11-23 00:05:21,163 - main - INFO - Shutting down Authentication Service...
2025-11-23 00:05:21,164 - main - INFO - Service is shutting down
2025-11-23 00:05:21,638 - main - INFO - Starting Authentication Service...
2025-11-23 00:05:21,638 - main - INFO - Service is starting up
2025-11-23 00:05:22,209 - main - INFO - Shutting down Authentication Service...
2025-11-23 00:05:22,209 - main - INFO - Service is shutting down
2025-11-23 00:05:22,706 - main - INFO - Starting Authentication Service...
2025-11-23 00:05:22,707 - main - INFO - Service is starting up
2025-11-23 00:05:23,272 - main - INFO - Shutting down Authentication Service...
2025-11-23 00:05:23,273 - main - INFO - Service is shutting down
2025-11-23 00:05:23,737 - main - INFO - Starting Authentication Service...
2025-11-23 00:05:23,737 - main - INFO - Service is starting up
2025-11-23 00:05:25,075 - main - INFO - Shutting down Authentication Service...
2025-11-23 00:05:25,076 - main - INFO - Service is shutting down
2025-11-23 00:05:25,555 - main - INFO - Starting Authentication Service...
2025-11-23 00:05:25,555 - main - INFO - Service is starting up
2025-11-23 00:05:26,564 - main - INFO - Shutting down Authentication Service...
2025-11-23 00:05:26,564 - main - INFO - Service is shutting down
2025-11-23 00:05:27,031 - main - INFO - Starting Authentication Service...
2025-11-23 00:05:27,031 - main - INFO - Service is starting up
2025-11-23 00:05:28,143 - main - INFO - Shutting down Authentication Service...
2025-11-23 00:05:28,144 - main - INFO - Service is shutting down
2025-11-23 00:05:28,623 - main - INFO - Starting Authentication Service...
2025-11-23 00:05:28,623 - main - INFO - Service is starting up
2025-11-23 00:05:29,193 - main - INFO - Shutting down Authentication Service...
2025-11-23 00:05:29,193 - main - INFO - Service is shutting down
2025-11-23 00:05:29,668 - main - INFO - Starting Authentication Service...
2025-11-23 00:05:29,668 - main - INFO - Service is starting up
2025-11-23 00:05:31,538 - main - INFO - Shutting down Authentication Service...
2025-11-23 00:05:31,539 - main - INFO - Service is shutting down
2025-11-23 00:05:32,011 - main - INFO - Starting Authentication Service...
2025-11-23 00:05:32,012 - main - INFO - Service is starting up
2025-11-23 00:05:32,797 - main - INFO - Shutting down Authentication Service...
2025-11-23 00:05:32,797 - main - INFO - Service is shutting down
2025-11-23 00:05:33,282 - main - INFO - Starting Authentication Service...
2025-11-23 00:05:33,282 - main - INFO - Service is starting up
2025-11-23 00:05:34,601 - main - INFO - Shutting down Authentication Service...
2025-11-23 00:05:34,601 - main - INFO - Service is shutting down
2025-11-23 00:05:35,077 - main - INFO - Starting Authentication Service...
2025-11-23 00:05:35,077 - main - INFO - Service is starting up
2025-11-23 00:05:36,948 - main - INFO - Shutting down Authentication Service...
2025-11-23 00:05:36,948 - main - INFO - Service is shutting down
2025-11-23 00:05:37,416 - main - INFO - Starting Authentication Service...
2025-11-23 00:05:37,416 - main - INFO - Service is starting up
2025-11-23 00:05:40,387 - main - INFO - Shutting down Authentication Service...
2025-11-23 00:05:40,387 - main - INFO - Service is shutting down
2025-11-23 00:05:40,872 - main - INFO - Starting Authentication Service...
2025-11-23 00:05:40,872 - main - INFO - Service is starting up
2025-11-23 00:05:42,412 - main - INFO - Shutting down Authentication Service...
2025-11-23 00:05:42,412 - main - INFO - Service is shutting down
2025-11-23 00:05:42,863 - main - INFO - Starting Authentication Service...
2025-11-23 00:05:42,864 - main - INFO - Service is starting up
2025-11-23 00:05:44,751 - main - INFO - Shutting down Authentication Service...
2025-11-23 00:05:44,751 - main - INFO - Service is shutting down
2025-11-23 00:05:45,197 - main - INFO - Starting Authentication Service...
2025-11-23 00:05:45,198 - main - INFO - Service is starting up
2025-11-23 00:05:46,559 - main - INFO - Shutting down Authentication Service...
2025-11-23 00:05:46,560 - main - INFO - Service is shutting down
2025-11-23 00:05:47,034 - main - INFO - Starting Authentication Service...
2025-11-23 00:05:47,034 - main - INFO - Service is starting up
2025-11-23 00:05:48,373 - main - INFO - Shutting down Authentication Service...
2025-11-23 00:05:48,373 - main - INFO - Service is shutting down
2025-11-23 00:05:48,850 - main - INFO - Starting Authentication Service...
2025-11-23 00:05:48,850 - main - INFO - Service is starting up
2025-11-23 00:05:50,189 - main - INFO - Shutting down Authentication Service...
2025-11-23 00:05:50,189 - main - INFO - Service is shutting down
2025-11-23 00:05:50,633 - main - INFO - Starting Authentication Service...
2025-11-23 00:05:50,634 - main - INFO - Service is starting up
2025-11-23 00:05:51,197 - main - INFO - Shutting down Authentication Service...
2025-11-23 00:05:51,197 - main - INFO - Service is shutting down
2025-11-23 00:05:51,665 - main - INFO - Starting Authentication Service...
2025-11-23 00:05:51,666 - main - INFO - Service is starting up
2025-11-23 00:08:38,618 - main - INFO - Shutting down Authentication Service...
2025-11-23 00:08:38,618 - main - INFO - Service is shutting down
2025-11-23 00:08:39,070 - main - INFO - Starting Authentication Service...
2025-11-23 00:08:39,071 - main - INFO - Service is starting up
2025-11-23 00:09:38,219 - main - INFO - Shutting down Authentication Service...
2025-11-23 00:09:38,219 - main - INFO - Service is shutting down
2025-11-23 00:09:38,683 - main - INFO - Starting Authentication Service...
2025-11-23 00:09:38,683 - main - INFO - Service is starting up
2025-11-23 00:09:46,799 - main - INFO - Shutting down Authentication Service...
2025-11-23 00:09:46,800 - main - INFO - Service is shutting down
2025-11-23 00:09:47,273 - main - INFO - Starting Authentication Service...
2025-11-23 00:09:47,274 - main - INFO - Service is starting up
2025-11-23 00:11:47,606 - main - INFO - Shutting down Authentication Service...
2025-11-23 00:11:47,606 - main - INFO - Service is shutting down
2025-11-23 00:11:48,089 - main - INFO - Starting Authentication Service...
2025-11-23 00:11:48,089 - main - INFO - Service is starting up
2025-11-23 00:11:51,824 - main - INFO - Shutting down Authentication Service...
2025-11-23 00:11:51,824 - main - INFO - Service is shutting down
2025-11-23 00:11:52,297 - main - INFO - Starting Authentication Service...
2025-11-23 00:11:52,297 - main - INFO - Service is starting up
2025-11-23 00:11:55,699 - main - INFO - Shutting down Authentication Service...
2025-11-23 00:11:55,700 - main - INFO - Service is shutting down
2025-11-23 00:11:56,207 - main - INFO - Starting Authentication Service...
2025-11-23 00:11:56,207 - main - INFO - Service is starting up
2025-11-23 00:12:59,751 - main - INFO - Shutting down Authentication Service...
2025-11-23 00:12:59,751 - main - INFO - Service is shutting down
2025-11-23 00:13:00,220 - main - INFO - Starting Authentication Service...
2025-11-23 00:13:00,220 - main - INFO - Service is starting up
2025-11-23 00:13:02,090 - main - INFO - Shutting down Authentication Service...
2025-11-23 00:13:02,090 - main - INFO - Service is shutting down
2025-11-23 00:13:02,537 - main - INFO - Starting Authentication Service...
2025-11-23 00:13:02,537 - main - INFO - Service is starting up
2025-11-23 00:13:40,557 - main - INFO - Shutting down Authentication Service...
2025-11-23 00:13:40,557 - main - INFO - Service is shutting down
2025-11-23 00:13:41,029 - main - INFO - Starting Authentication Service...
2025-11-23 00:13:41,029 - main - INFO - Service is starting up
2025-11-23 00:13:49,166 - main - INFO - Shutting down Authentication Service...
2025-11-23 00:13:49,166 - main - INFO - Service is shutting down
2025-11-23 00:13:49,644 - main - INFO - Starting Authentication Service...
2025-11-23 00:13:49,645 - main - INFO - Service is starting up
2025-11-23 00:14:00,499 - main - INFO - Shutting down Authentication Service...
2025-11-23 00:14:00,500 - main - INFO - Service is shutting down
2025-11-23 00:14:00,948 - main - INFO - Starting Authentication Service...
2025-11-23 00:14:00,948 - main - INFO - Service is starting up
2025-11-23 00:14:07,209 - main - INFO - Shutting down Authentication Service...
2025-11-23 00:14:07,209 - main - INFO - Service is shutting down
2025-11-23 00:14:07,681 - main - INFO - Starting Authentication Service...
2025-11-23 00:14:07,682 - main - INFO - Service is starting up
2025-11-23 00:15:42,872 - main - INFO - Shutting down Authentication Service...
2025-11-23 00:15:42,873 - main - INFO - Service is shutting down
2025-11-23 00:15:43,371 - main - INFO - Starting Authentication Service...
2025-11-23 00:15:43,372 - main - INFO - Service is starting up
2025-11-23 00:15:58,367 - main - INFO - Shutting down Authentication Service...
2025-11-23 00:15:58,367 - main - INFO - Service is shutting down
2025-11-23 00:15:58,875 - main - INFO - Starting Authentication Service...
2025-11-23 00:15:58,875 - main - INFO - Service is starting up
2025-11-23 00:19:25,101 - main - INFO - Shutting down Authentication Service...
2025-11-23 00:19:25,102 - main - INFO - Service is shutting down
2025-11-23 00:19:25,558 - main - INFO - Starting Authentication Service...
2025-11-23 00:19:25,561 - main - INFO - Service is starting up
2025-11-23 00:21:10,818 - main - INFO - Shutting down Authentication Service...
2025-11-23 00:21:10,818 - main - INFO - Service is shutting down
2025-11-23 00:21:11,305 - main - INFO - Starting Authentication Service...
2025-11-23 00:21:11,305 - main - INFO - Service is starting up
2025-11-23 00:21:39,062 - main - INFO - Shutting down Authentication Service...
2025-11-23 00:21:39,062 - main - INFO - Service is shutting down
2025-11-23 00:21:39,503 - main - INFO - Starting Authentication Service...
2025-11-23 00:21:39,503 - main - INFO - Service is starting up
2025-11-23 00:22:35,683 - main - INFO - Shutting down Authentication Service...
2025-11-23 00:22:35,683 - main - INFO - Service is shutting down
2025-11-23 00:22:36,172 - main - INFO - Starting Authentication Service...
2025-11-23 00:22:36,172 - main - INFO - Service is starting up
2025-11-23 00:22:38,494 - main - INFO - Shutting down Authentication Service...
2025-11-23 00:22:38,494 - main - INFO - Service is shutting down
2025-11-23 00:22:38,946 - main - INFO - Starting Authentication Service...
2025-11-23 00:22:38,946 - main - INFO - Service is starting up
2025-11-23 00:22:41,907 - main - INFO - Shutting down Authentication Service...
2025-11-23 00:22:41,907 - main - INFO - Service is shutting down
2025-11-23 00:22:42,370 - main - INFO - Starting Authentication Service...
2025-11-23 00:22:42,370 - main - INFO - Service is starting up
2025-11-23 00:22:58,466 - main - INFO - Shutting down Authentication Service...
2025-11-23 00:22:58,466 - main - INFO - Service is shutting down
2025-11-23 00:22:58,936 - main - INFO - Starting Authentication Service...
2025-11-23 00:22:58,937 - main - INFO - Service is starting up
2025-11-23 00:23:01,041 - main - INFO - Shutting down Authentication Service...
2025-11-23 00:23:01,041 - main - INFO - Service is shutting down
2025-11-23 00:23:01,527 - main - INFO - Starting Authentication Service...
2025-11-23 00:23:01,528 - main - INFO - Service is starting up
2025-11-23 00:23:03,619 - main - INFO - Shutting down Authentication Service...
2025-11-23 00:23:03,619 - main - INFO - Service is shutting down
2025-11-23 00:23:04,086 - main - INFO - Starting Authentication Service...
2025-11-23 00:23:04,086 - main - INFO - Service is starting up
2025-11-23 00:23:25,007 - main - INFO - Shutting down Authentication Service...
2025-11-23 00:23:25,008 - main - INFO - Service is shutting down
2025-11-23 00:23:25,511 - main - INFO - Starting Authentication Service...
2025-11-23 00:23:25,512 - main - INFO - Service is starting up
2025-11-23 00:23:26,624 - main - INFO - Shutting down Authentication Service...
2025-11-23 00:23:26,625 - main - INFO - Service is shutting down
2025-11-23 00:23:27,105 - main - INFO - Starting Authentication Service...
2025-11-23 00:23:27,106 - main - INFO - Service is starting up
2025-11-23 00:23:28,988 - main - INFO - Shutting down Authentication Service...
2025-11-23 00:23:28,988 - main - INFO - Service is shutting down
2025-11-23 00:23:29,433 - main - INFO - Starting Authentication Service...
2025-11-23 00:23:29,434 - main - INFO - Service is starting up
2025-11-23 13:14:47,469 - main - INFO - Starting Authentication Service...
2025-11-23 13:14:47,469 - main - INFO - Service is starting up
2025-11-23 13:31:45,148 - main - INFO - Shutting down Authentication Service...
2025-11-23 13:31:45,149 - main - INFO - Service is shutting down


============================================================
FILE: .\pytest.ini
============================================================

[pytest]
pythonpath = 
    ./
    ./api/auth/app/
testpaths = ./api/auth/app/tests
python_files = test_*.py
python_classes = Test*
python_functions = test_*
addopts = 
    -v
    --tb=short
    --strict-markers
    --strict-config
    --disable-warnings
markers =
    slow: marks tests as slow (deselect with '-m "not slow"')
    integration: marks tests as integration tests
    unit: marks tests as unit tests

============================================================
FILE: .\__init__.py
============================================================



============================================================
FILE: .\authentication\tools.py
============================================================

import bcrypt
import jwt
import os
from datetime import datetime, timedelta
from decorators.auth_tools_decorators import TokenToolsDecorators, PasswordToolsDecorators, PasswordErrorHandler, TokenErrorHandler

# Environment variables with defaults
JWT_SECRET_KEY = os.getenv('JWT_SECRET_KEY', 'random-secret-key')
ACCESS_TOKEN_EXPIRE_SECONDS = int(os.getenv('ACCESS_TOKEN_EXPIRE_SECONDS', '280'))
REFRESH_TOKEN_EXPIRE_DAYS = int(os.getenv('REFRESH_TOKEN_EXPIRE_DAYS', '7'))

class PasswordTools:
    def __init__(self):
        pass

    @PasswordToolsDecorators.handle_encode_error
    def encode_password(self, plain_password: str) -> str:
        if plain_password is None:
            raise ValueError('password cannot be None.')
        
        salt = bcrypt.gensalt()
        hashed = bcrypt.hashpw(plain_password.encode('utf-8'), salt).decode('utf-8')
        return hashed

    def verify_password(self, plain_password: str, hashed_password: str) -> bool:
        if plain_password is None:
            raise ValueError('password cannot be None.')
       
        if not hashed_password or not isinstance(hashed_password, str):
            raise ValueError("Invalid hashed password")
        
        try:
            return bcrypt.checkpw(plain_password.encode('utf-8'), hashed_password.encode('utf-8'))
        except (ValueError, TypeError) as e:
            raise ValueError('Invalid hashed password format')
        except Exception as e:
            PasswordErrorHandler.handle_verify_error(e)

class TokenTools:
    def __init__(self):
        pass

    @TokenToolsDecorators.handle_creation_error
    def create_access_token(self, user_payload: dict) -> str:
        if user_payload is None:
            raise ValueError('user data cannot be None.')
        
        expiration = datetime.now() + timedelta(seconds=ACCESS_TOKEN_EXPIRE_SECONDS)
        token_payload = {
            **user_payload,
            'expiration': expiration.timestamp(),
            'issued_at': datetime.now().timestamp(),
            'type': 'access'
        }
        return jwt.encode(token_payload, JWT_SECRET_KEY, algorithm='HS256')

    @TokenToolsDecorators.handle_creation_error
    def create_refresh_token(self, user_payload: dict) -> str:
        expiration = datetime.now() + timedelta(days=REFRESH_TOKEN_EXPIRE_DAYS)
        token_payload = {
            **user_payload,
            'expiration': expiration.timestamp(),
            'issued_at': datetime.now().timestamp(),
            'type': 'refresh'
        }
        return jwt.encode(token_payload, JWT_SECRET_KEY, algorithm='HS256')

    def validate_token(self, token: str, token_type: str = "access") -> bool:
        if token is None:
            raise ValueError("Token cannot be None")
        
        try:
            payload = jwt.decode(token, JWT_SECRET_KEY, algorithms=['HS256'])
            
            if token_type and payload.get('type') != token_type:
                return False
                
            return True
        except (jwt.ExpiredSignatureError, jwt.InvalidTokenError):
            return False
        except Exception as e:
            return TokenErrorHandler.handle_validation_error(e)

    @TokenToolsDecorators.handle_payload_error
    def get_token_payload(self, token: str) -> dict:
        if token is None:
            raise ValueError("Token cannot be None")
        
        if not token:
            raise ValueError("Token cannot be empty")
        
        payload = jwt.decode(token, JWT_SECRET_KEY, algorithms=['HS256'])
        
        expiration_timestamp = payload.get('expiration')
        if expiration_timestamp and datetime.now().timestamp() > expiration_timestamp:
            raise ValueError("Token has expired")
        
        # clean_payload is only the user's data
        clean_payload = {
            k: v for k, v in payload.items() 
            if k not in ['expiration', 'issued_at', 'type']
        }
        return clean_payload

    @TokenToolsDecorators.handle_refresh_error
    def refresh_access_token(self, refresh_token: str) -> str:
        if not refresh_token:
            raise ValueError("Refresh token cannot be empty")
        
        if not self.validate_token(refresh_token, "refresh"):
            raise ValueError("Invalid or expired refresh token")
        
        payload = self.get_token_payload(refresh_token)
        user_id = payload.get('user_id')
        
        if not user_id:
            raise ValueError("Invalid refresh token payload")
        
        user_data = {'user_id': user_id}
        
        new_access_token = self.create_access_token(user_data)
        
        return new_access_token

============================================================
FILE: .\authentication\__init__.py
============================================================



============================================================
FILE: .\database\models.py
============================================================

from pydantic import BaseModel, EmailStr, Field, field_validator, ConfigDict
from typing import Optional
from datetime import datetime


class RegisterRequest(BaseModel):
    email: EmailStr
    password: str = Field(..., min_length=8, description="Password must be at least 8 characters long")
    name: str = Field(..., min_length=1, description="Name is required")

    @field_validator('password')
    def password_strength(cls, v):
        if len(v) < 8:
            raise ValueError('Password must be at least 8 characters long')
        
        if len(v) > 128:
            raise ValueError('Password must be less than 128 characters')
        
        if not any(c.isupper() for c in v):
            raise ValueError('Password must contain at least one uppercase letter')
        
        if not any(c.islower() for c in v):
            raise ValueError('Password must contain at least one lowercase letter')
        
        if not any(c.isdigit() for c in v):
            raise ValueError('Password must contain at least one digit')
        
        special_chars = "!@#$%^&*()_+-=[]{}|;:,.<>?"
        if not any(c in special_chars for c in v):
            raise ValueError('Password must contain at least one special character')
        
        weak_passwords = {'password', '12345678', 'qwertyui', 'admin123', 'letmein'}
        if v.lower() in weak_passwords:
            raise ValueError('Password is too common, please choose a stronger one')
        
        for i in range(len(v) - 2):
            if v[i:i+3].isalpha() and ord(v[i+1]) == ord(v[i]) + 1 and ord(v[i+2]) == ord(v[i]) + 2:
                raise ValueError('Password contains sequential characters')
        
        return v


class LoginRequest(BaseModel):
    email: EmailStr
    password: str = Field(..., min_length=1, description="Password is required")


class RefreshTokenRequest(BaseModel):
    refresh_token: str = Field(..., alias="refreshToken", description="Refresh token is required")


class PasswordChangeRequest(BaseModel):
    old_password: str = Field(..., alias="oldPassword", description="Old password is required")
    new_password: str = Field(..., alias="newPassword", min_length=8, description="New password must be at least 8 characters long")


class ProfileUpdateRequest(BaseModel):
    name: Optional[str] = Field(None, min_length=1, description="Name cannot be empty")
    phone: Optional[str] = Field(None, min_length=1, description="Phone cannot be empty")

    @field_validator('*', mode='before')
    def empty_string_to_none(cls, v):
        if v == "":
            return None
        return v


class UserResponse(BaseModel):
    id: str
    email: EmailStr
    name: str

    model_config = ConfigDict(from_attributes=True)


class TokenResponse(BaseModel):
    access_token: str = Field(..., alias="accessToken")
    refresh_token: str = Field(..., alias="refreshToken")


class AccessTokenResponse(BaseModel):
    access_token: str = Field(..., alias="accessToken")


class UserCreate(BaseModel):
    email: EmailStr
    password_hash: str
    name: str


class UserInDB(BaseModel):
    id: str
    email: EmailStr
    password_hash: str
    name: str
    created_at: datetime
    updated_at: datetime

    model_config = ConfigDict(from_attributes=True)


class TokenPayload(BaseModel):
    user_id: str
    email: EmailStr
    name: str


class ErrorResponse(BaseModel):
    type: str
    title: str
    status: int
    detail: str
    instance: Optional[str] = None

============================================================
FILE: .\decorators\auth_routes_decorators.py
============================================================

from functools import wraps
from fastapi import Request, Depends, HTTPException, status
from typing import Callable, Any
from authentication.tools import PasswordTools, TokenTools
from services.auth_services import AuthService

class AuthErrorDecorators:
    
    @staticmethod
    def handle_register_errors(func: Callable) -> Callable:
        @wraps(func)
        async def wrapper(
            request: Request,
            register_data: Any,
            password_tools: PasswordTools = Depends(lambda: PasswordTools()),
            auth_service: AuthService = Depends(lambda: AuthService()),
            *args, **kwargs
        ) -> Any:
            try:
                return await func(request, register_data, password_tools, auth_service, *args, **kwargs)
            except Exception as e:
                AuthErrorDecorators._handle_register_exception(e, request)
        return wrapper
    
    @staticmethod
    def handle_login_errors(func: Callable) -> Callable:
        @wraps(func)
        async def wrapper(
            request: Request,
            login_data: Any,
            password_tools: PasswordTools = Depends(lambda: PasswordTools()),
            token_tools: TokenTools = Depends(lambda: TokenTools()),
            auth_service: AuthService = Depends(lambda: AuthService()),
            *args, **kwargs
        ) -> Any:
            try:
                return await func(request, login_data, password_tools, token_tools, auth_service, *args, **kwargs)
            except Exception as e:
                AuthErrorDecorators._handle_login_exception(e, request)
        return wrapper
    
    @staticmethod
    def handle_token_errors(func: Callable) -> Callable:
        @wraps(func)
        async def wrapper(
            request: Request,
            data: Any = None,
            token_tools: TokenTools = Depends(lambda: TokenTools()),
            auth_service: AuthService = Depends(lambda: AuthService()),
            *args, **kwargs
        ) -> Any:
            try:
                return await func(request, data, token_tools, auth_service, *args, **kwargs)
            except Exception as e:
                AuthErrorDecorators._handle_token_exception(e, request)
        return wrapper
    
    @staticmethod
    def handle_profile_errors(func: Callable) -> Callable:
        @wraps(func)
        async def wrapper(
            request: Request,
            token: str,
            token_tools: TokenTools = Depends(lambda: TokenTools()),
            auth_service: AuthService = Depends(lambda: AuthService()),
            *args, **kwargs
        ) -> Any:
            try:
                return await func(request, token, token_tools, auth_service, *args, **kwargs)
            except Exception as e:
                AuthErrorDecorators._handle_profile_exception(e, request)
        return wrapper
    
    @staticmethod
    def handle_logout_errors(func: Callable) -> Callable:
        @wraps(func)
        async def wrapper(
            request: Request,
            token: str,
            token_tools: TokenTools = Depends(lambda: TokenTools()),
            auth_service: AuthService = Depends(lambda: AuthService()),
            *args, **kwargs
        ) -> Any:
            try:
                return await func(request, token, token_tools, auth_service, *args, **kwargs)
            except Exception as e:
                AuthErrorDecorators._handle_logout_exception(e, request)
        return wrapper
    
    @staticmethod
    def _handle_register_exception(error: Exception, request: Request) -> None:
        error_str = str(error).lower()
        
        if "duplicate" in error_str or "already exists" in error_str:
            raise HTTPException(
                status_code=status.HTTP_409_CONFLICT,
                detail="User already exists"
            )
        elif "validation" in error_str or "invalid" in error_str:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=str(error)
            )
        else:
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail="Registration failed"
            )
    
    @staticmethod
    def _handle_login_exception(error: Exception, request: Request) -> None:
        error_str = str(error).lower()
        
        if "invalid" in error_str or "incorrect" in error_str or "not found" in error_str:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid credentials"
            )
        elif "validation" in error_str:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=str(error)
            )
        else:
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail="Login failed"
            )
    
    @staticmethod
    def _handle_token_exception(error: Exception, request: Request) -> None:
        error_str = str(error).lower()
        
        if "invalid" in error_str or "expired" in error_str or "signature" in error_str:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid or expired token"
            )
        elif "missing" in error_str or "empty" in error_str:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Missing token"
            )
        elif "validation" in error_str:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=str(error)
            )
        elif "refresh" in error_str:
            if "invalid" in error_str or "expired" in error_str:
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    detail="Invalid or expired refresh token"
                )
            else:
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail="Invalid refresh token"
                )
        else:
            import logging
            logger = logging.getLogger(__name__)
            logger.error(f"Token error: {error}")
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Invalid token request"
            )
            
    @staticmethod
    def _handle_profile_exception(error: Exception, request: Request) -> None:
        error_str = str(error).lower()
        
        if "invalid" in error_str or "expired" in error_str:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid or expired token"
            )
        elif "not found" in error_str:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="User not found"
            )
        else:
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail="Profile retrieval failed"
            )
    
    @staticmethod
    def _handle_logout_exception(error: Exception, request: Request) -> None:
        error_str = str(error).lower()
        
        if "invalid" in error_str or "expired" in error_str:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid or expired token"
            )
        elif "missing" in error_str:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Missing token"
            )
        else:
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail="Logout failed"
            )

============================================================
FILE: .\decorators\auth_tools_decorators.py
============================================================

from functools import wraps

class PasswordErrorHandler:
    @staticmethod
    def handle_encode_error(error: Exception) -> str:
        if isinstance(error, ValueError):
            raise error
        raise ValueError("Failed to encode password") from error

    @staticmethod
    def handle_verify_error(error: Exception) -> bool:
        if isinstance(error, ValueError):
            raise error
        raise ValueError("Failed to verify password") from error


class TokenErrorHandler:
    @staticmethod
    def handle_creation_error(error: Exception) -> str:
        if isinstance(error, ValueError):
            raise error
        raise ValueError("Failed to create token") from error

    @staticmethod
    def handle_validation_error(error: Exception) -> bool:
        if isinstance(error, ValueError):
            raise error
        return False

    @staticmethod
    def handle_payload_error(error: Exception) -> dict:
        if isinstance(error, ValueError):
            raise error
        raise ValueError("Failed to get token payload") from error

    @staticmethod
    def handle_refresh_error(error: Exception) -> str:
        if isinstance(error, ValueError):
            raise error
        raise ValueError("Failed to refresh token") from error


class PasswordToolsDecorators:
    
    @staticmethod
    def handle_encode_error(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            try:
                return func(*args, **kwargs)
            except Exception as e:
                PasswordErrorHandler.handle_encode_error(e)
        return wrapper

    @staticmethod
    def handle_verify_error(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            try:
                return func(*args, **kwargs)
            except Exception as e:
                PasswordErrorHandler.handle_verify_error(e)
        return wrapper

class TokenToolsDecorators:
    
    @staticmethod
    def handle_creation_error(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            try:
                return func(*args, **kwargs)
            except Exception as e:
                TokenErrorHandler.handle_creation_error(e)
        return wrapper

    @staticmethod
    def handle_payload_error(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            try:
                return func(*args, **kwargs)
            except Exception as e:
                TokenErrorHandler.handle_payload_error(e)
        return wrapper

    @staticmethod
    def handle_refresh_error(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            try:
                return func(*args, **kwargs)
            except Exception as e:
                TokenErrorHandler.handle_refresh_error(e)
        return wrapper

============================================================
FILE: .\routes\auth_routes.py
============================================================

import logging
from fastapi import APIRouter, Request, Depends, Header
from typing import Dict
from authentication.tools import PasswordTools, TokenTools
from services.auth_services import AuthService
from database import models
from decorators.auth_routes_decorators import AuthErrorDecorators

logger = logging.getLogger(__name__)

router = APIRouter(prefix='/auth', tags=['auth'])

# Dependency injection functions
def get_token_tools() -> TokenTools:
    return TokenTools()

def get_password_tools() -> PasswordTools:
    return PasswordTools()

def get_auth_service() -> AuthService:
    return AuthService(logger=logger)

async def get_token_from_header(authorization: str = Header(None)) -> str:
    if not authorization or not authorization.startswith("Bearer "):
        from fastapi import HTTPException, status
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Missing or invalid Authorization header"
        )
    return authorization[7:]

@router.post(
    '/register',
    response_model=models.UserResponse,
    status_code=201,
    summary="Register new user"
)
@AuthErrorDecorators.handle_register_errors
async def register_user(
    request: Request,
    register_data: models.RegisterRequest,
    password_tools: PasswordTools = Depends(get_password_tools),
    auth_service: AuthService = Depends(get_auth_service),
) -> models.UserResponse:
    return await auth_service.register_user(request, register_data, password_tools)

@router.post(
    '/login',
    response_model=Dict[str, str],
    summary="Login user (returns access + refresh tokens)"
)
@AuthErrorDecorators.handle_login_errors
async def login_user(
    request: Request,
    login_data: models.LoginRequest,
    password_tools: PasswordTools = Depends(get_password_tools),
    token_tools: TokenTools = Depends(get_token_tools),
    auth_service: AuthService = Depends(get_auth_service),
) -> Dict[str, str]:
    return await auth_service.login_user(request, login_data, password_tools, token_tools)

@router.post(
    '/refresh-token',
    response_model=Dict[str, str],
    summary="Refresh access token using refresh token"
)
@AuthErrorDecorators.handle_token_errors
async def refresh_token(
    request: Request,
    refresh_data: models.RefreshTokenRequest,
    token_tools: TokenTools = Depends(get_token_tools),
    auth_service: AuthService = Depends(get_auth_service),
) -> Dict[str, str]:
    return await auth_service.refresh_token(request, refresh_data, token_tools)

@router.post(
    '/logout',
    status_code=204,
    summary="Logout user (revoke refresh token)"
)
@AuthErrorDecorators.handle_logout_errors
async def logout(
    request: Request,
    token: str = Depends(get_token_from_header),
    token_tools: TokenTools = Depends(get_token_tools),
    auth_service: AuthService = Depends(get_auth_service),
) -> None:
    return await auth_service.logout(request, token, token_tools)

@router.get(
    '/me',
    response_model=models.UserResponse,
    summary="Get current user profile"
)
@AuthErrorDecorators.handle_profile_errors
async def get_current_user(
    request: Request,
    token: str = Depends(get_token_from_header),
    token_tools: TokenTools = Depends(get_token_tools),
    auth_service: AuthService = Depends(get_auth_service),
) -> models.UserResponse:
    return await auth_service.get_current_user(request, token, token_tools)

============================================================
FILE: .\services\auth_helpers.py
============================================================

from fastapi.responses import JSONResponse

def create_problem_response(
    status_code: int,
    error_type: str,
    title: str,
    detail: str,
    instance: str
) -> JSONResponse:
    problem_details = {
        "type": f"https://example.com/errors/{error_type}",
        "title": title,
        "status": status_code,
        "detail": detail,
        "instance": instance
    }
    return JSONResponse(
        status_code=status_code,
        content=problem_details,
        media_type="application/problem+json"
    )

============================================================
FILE: .\services\auth_services.py
============================================================

from .auth_helpers import create_problem_response
from fastapi import Request
from fastapi.responses import JSONResponse
from typing import Dict
from authentication.tools import PasswordTools, TokenTools
from database import models

class AuthService:
    def __init__(self, logger):
        self.logger = logger

    async def register_user(
        self,
        request: Request,
        register_data: models.RegisterRequest,
        password_tools: PasswordTools
    ) -> models.UserResponse:
        self.logger.info(f"Registration attempt for email: {register_data.email}")
        
        user_exists = False
        
        if user_exists:
            return create_problem_response(
                status_code=409,
                error_type="conflict",
                title="Conflict",
                detail="Duplicate resource.",
                instance=str(request.url)
            )
        
        hashed_password = password_tools.encode_password(register_data.password)
        
        mock_user = models.UserResponse(
            id="user_123",
            email=register_data.email,
            name=register_data.name
        )
        
        self.logger.info(f"User registered successfully: {register_data.email}")
        
        response = JSONResponse(
            status_code=201,
            content=mock_user.model_dump(),
            headers={"Location": f"/api/users/{mock_user.id}"}
        )
        return response

    async def login_user(
        self,
        request: Request,
        login_data: models.LoginRequest,
        password_tools: PasswordTools,
        token_tools: TokenTools
    ) -> Dict[str, str]:
        self.logger.info(f"Login attempt for email: {login_data.email}")
        
        mock_user_data = {
            "id": "user_123",
            "email": login_data.email,
            "name": "Test User",
            "password_hash": password_tools.encode_password("CorrectPassword123!")
        }
        
        is_password_valid = False
        
        if not is_password_valid:
            self.logger.warning(f"Invalid login attempt for email: {login_data.email}")
            return create_problem_response(
                status_code=401,
                error_type="unauthorized",
                title="Unauthorized",
                detail="Invalid email or password",
                instance=str(request.url)
            )
        
        token_payload = {
            "user_id": mock_user_data["id"],
            "email": mock_user_data["email"],
            "name": mock_user_data["name"]
        }
        
        access_token = token_tools.create_access_token(token_payload)
        refresh_token = token_tools.create_refresh_token(token_payload)
        
        self.logger.info(f"User logged in successfully: {login_data.email}")
        return {
            "accessToken": access_token,
            "refreshToken": refresh_token
        }

    async def refresh_token(
        self,
        request: Request,
        refresh_data: models.RefreshTokenRequest,
        token_tools: TokenTools
    ) -> Dict[str, str]:
        self.logger.info("Refresh token request received")
        
        new_access_token = token_tools.refresh_access_token(refresh_data.refresh_token)
        
        self.logger.info("Access token refreshed successfully")
        return {"accessToken": new_access_token}

    async def logout(
        self,
        request: Request,
        token: str,
        token_tools: TokenTools
    ) -> None:
        if not token_tools.validate_token(token):
            return create_problem_response(
                status_code=401,
                error_type="unauthorized",
                title="Unauthorized",
                detail="Invalid token",
                instance=str(request.url)
            )
        
        self.logger.info("User logged out successfully")
        return None

    async def get_current_user(
        self,
        request: Request,
        token: str,
        token_tools: TokenTools
    ) -> models.UserResponse:
        if not token_tools.validate_token(token):
            return create_problem_response(
                status_code=401,
                error_type="unauthorized",
                title="Unauthorized",
                detail="Invalid or expired token",
                instance=str(request.url)
            )
        
        payload = token_tools.get_token_payload(token)
        user_id = payload.get("user_id")
        email = payload.get("email")
        name = payload.get("name")
        
        if not all([user_id, email, name]):
            return create_problem_response(
                status_code=401,
                error_type="unauthorized",
                title="Unauthorized",
                detail="Invalid token payload",
                instance=str(request.url)
            )
        
        user_data = models.UserResponse(
            id=user_id,
            email=email,
            name=name
        )
        
        self.logger.info(f"User profile retrieved: {email}")
        return user_data

============================================================
FILE: .\tests\test_auth_contract.py
============================================================

import pytest
import pytest_asyncio
from httpx import ASGITransport, AsyncClient
from main import app


class TestAuthAPIContract:    
    @pytest_asyncio.fixture
    async def client(self):
        async with AsyncClient(transport=ASGITransport(app=app), base_url="http://test") as client:
            yield client

    @pytest.mark.asyncio
    async def test_health_endpoint(self, client):
        response = await client.get("/health")
        
        assert response.status_code == 200
        data = response.json()
        assert "status" in data
        assert "service" in data
        assert "timestamp" in data
        assert data["service"] == "authentication"

    @pytest.mark.asyncio
    async def test_root_endpoint(self, client):
        response = await client.get("/")
        
        assert response.status_code == 200
        data = response.json()
        assert "message" in data
        assert "version" in data
        assert "docs" in data
        assert "health" in data

    @pytest.mark.asyncio
    async def test_register_user_contract(self, client):
        register_data = {
            "email": "contract@test.com",
            "password": "SecurePass123!",
            "name": "Contract Test User"
        }
        
        response = await client.post("/api/auth/register", json=register_data)
        
        assert response.status_code in [201, 409]
        
        if response.status_code == 201:
            data = response.json()
            assert "id" in data
            assert "email" in data
            assert "name" in data
            assert data["email"] == register_data["email"]
            assert data["name"] == register_data["name"]
            
            assert "Location" in response.headers
            assert "/api/users/" in response.headers["Location"]

    @pytest.mark.asyncio
    async def test_register_user_validation_contract(self, client):
        invalid_data = {
            "email": "invalid-email",
            "password": "weak",
            "name": ""
        }
        
        response = await client.post("/api/auth/register", json=invalid_data)
        
        assert response.status_code == 422

    @pytest.mark.asyncio
    async def test_login_user_contract(self, client):
        login_data = {
            "email": "test@example.com",
            "password": "CorrectPassword123!"
        }
        
        response = await client.post("/api/auth/login", json=login_data)
        
        assert response.status_code in [200, 401]
        
        if response.status_code == 200:
            data = response.json()
            assert "accessToken" in data
            assert "refreshToken" in data
            assert isinstance(data["accessToken"], str)
            assert isinstance(data["refreshToken"], str)

    @pytest.mark.asyncio
    async def test_login_user_invalid_contract(self, client):
        login_data = {
            "email": "test@example.com",
            "password": "WrongPassword"
        }
        
        response = await client.post("/api/auth/login", json=login_data)
        
        if response.status_code == 401:
            data = response.json()
            assert "type" in data
            assert "title" in data
            assert "status" in data
            assert "detail" in data
            assert data["status"] == 401
            assert data["title"] == "Unauthorized"

    @pytest.mark.asyncio
    async def test_refresh_token_contract(self, client):
        refresh_data = {
            "refreshToken": "mock_refresh_token"
        }
        
        response = await client.post("/api/auth/refresh-token", json=refresh_data)
        
        assert response.status_code in [200, 400, 401]
        
        if response.status_code == 200:
            data = response.json()
            assert "accessToken" in data
            assert isinstance(data["accessToken"], str)

    @pytest.mark.asyncio
    async def test_get_current_user_contract(self, client):
        response = await client.get("/api/auth/me")
        assert response.status_code == 401  # Changed from 422 to 401
        
        response = await client.get("/api/auth/me", headers={"Authorization": "Invalid"})
        assert response.status_code == 401  # Changed from 422 to 401
        
        response = await client.get("/api/auth/me", headers={"Authorization": "Bearer invalid_token"})
        assert response.status_code in [200, 401]

    @pytest.mark.asyncio
    async def test_logout_contract(self, client):
        response = await client.post("/api/auth/logout")
        assert response.status_code == 401  # Changed from 422 to 401
        
        response = await client.post("/api/auth/logout", headers={"Authorization": "Bearer mock_token"})
        assert response.status_code in [204, 401]

    @pytest.mark.asyncio
    async def test_problem_json_response_contract(self, client):
        login_data = {
            "email": "test@example.com",
            "password": "WrongPassword"
        }
        response = await client.post("/api/auth/login", json=login_data)
        
        if response.status_code == 401:
            data = response.json()
            assert "type" in data
            assert "title" in data
            assert "status" in data
            assert "detail" in data
            assert data["status"] == 401


class TestAuthAPIErrorScenarios:
    
    @pytest_asyncio.fixture
    async def client(self):
        async with AsyncClient(transport=ASGITransport(app=app), base_url="http://test") as client:
            yield client

    @pytest.mark.asyncio
    async def test_malformed_json_contract(self, client):
        response = await client.post(
            "/api/auth/register",
            content="{invalid json",
            headers={"Content-Type": "application/json"}
        )
        assert response.status_code == 422

    @pytest.mark.asyncio
    async def test_unsupported_media_type_contract(self, client):
        response = await client.post(
            "/api/auth/register",
            content="email=test@test.com",
            headers={"Content-Type": "application/x-www-form-urlencoded"}
        )
        assert response.status_code == 422

    @pytest.mark.asyncio
    async def test_method_not_allowed_contract(self, client):
        response = await client.put("/api/auth/register")
        assert response.status_code == 405

    @pytest.mark.asyncio
    async def test_cors_headers_contract(self, client):
        response = await client.get("/health", headers={"Origin": "http://localhost:3000"})
        
        if "access-control-allow-origin" in response.headers:
            assert response.headers["access-control-allow-origin"] == "http://localhost:3000"

============================================================
FILE: .\tests\test_auth_services.py
============================================================

import pytest
import pytest_asyncio
from unittest.mock import Mock
from fastapi import Request
from fastapi.responses import JSONResponse
from fastapi.testclient import TestClient
from main import app
from services.auth_services import AuthService
from authentication.tools import PasswordTools, TokenTools
from database import models


class TestAuthService:
    @pytest.fixture
    def client(self):
        return TestClient(app)

    @pytest_asyncio.fixture
    async def mock_logger(self):
        return Mock()

    @pytest_asyncio.fixture
    async def mock_request(self):
        request = Mock(spec=Request)
        request.url = "http://testserver/api/auth/register"
        return request

    @pytest_asyncio.fixture
    async def mock_password_tools(self):
        tools = Mock(spec=PasswordTools)
        tools.encode_password = Mock(return_value="hashed_password_123")
        tools.verify_password = Mock(return_value=True)
        return tools

    @pytest_asyncio.fixture
    async def mock_token_tools(self):
        tools = Mock(spec=TokenTools)
        tools.create_access_token = Mock(return_value="mock_access_token")
        tools.create_refresh_token = Mock(return_value="mock_refresh_token")
        tools.refresh_access_token = Mock(return_value="new_access_token")
        tools.validate_token = Mock(return_value=True)
        tools.get_token_payload = Mock(return_value={
            "user_id": "user_123",
            "email": "test@example.com",
            "name": "Test User"
        })
        return tools

    @pytest_asyncio.fixture
    async def auth_service(self, mock_logger):
        return AuthService(logger=mock_logger)

    def test_client_initialization(self, client):
        response = client.get("/health")
        assert response.status_code == 200

    @pytest.mark.asyncio
    async def test_register_user_success(
        self, auth_service, mock_request, mock_password_tools
    ):
        register_data = models.RegisterRequest(
            email="test@example.com",
            password="SecurePass123!",
            name="Test User"
        )

        result = await auth_service.register_user(
            mock_request, register_data, mock_password_tools
        )

        assert isinstance(result, JSONResponse)
        assert result.status_code == 201
        assert "Location" in result.headers
        assert "/api/users/user_123" in result.headers["Location"]
        
        auth_service.logger.info.assert_any_call("Registration attempt for email: test@example.com")
        auth_service.logger.info.assert_any_call("User registered successfully: test@example.com")
        
        mock_password_tools.encode_password.assert_called_once_with("SecurePass123!")

    @pytest.mark.asyncio
    async def test_login_user_success(
        self, auth_service, mock_request, mock_password_tools, mock_token_tools
    ):
        login_data = models.LoginRequest(
            email="test@example.com",
            password="CorrectPassword123!"
        )

        result = await auth_service.login_user(
            mock_request, login_data, mock_password_tools, mock_token_tools
        )

        assert isinstance(result, JSONResponse)
        assert result.status_code == 401
        
        auth_service.logger.info.assert_called_with("Login attempt for email: test@example.com")
        auth_service.logger.warning.assert_called_with("Invalid login attempt for email: test@example.com")

    @pytest.mark.asyncio
    async def test_login_user_invalid_credentials(
        self, auth_service, mock_request, mock_password_tools, mock_token_tools
    ):
        login_data = models.LoginRequest(
            email="test@example.com",
            password="WrongPassword"
        )

        result = await auth_service.login_user(
            mock_request, login_data, mock_password_tools, mock_token_tools
        )

        assert isinstance(result, JSONResponse)
        assert result.status_code == 401
        
        auth_service.logger.warning.assert_called_once_with(
            "Invalid login attempt for email: test@example.com"
        )

    @pytest.mark.asyncio
    async def test_refresh_token_success(
        self, auth_service, mock_request, mock_token_tools
    ):
        refresh_data = models.RefreshTokenRequest(refreshToken="valid_refresh_token")

        result = await auth_service.refresh_token(
            mock_request, refresh_data, mock_token_tools
        )

        assert isinstance(result, dict)
        assert "accessToken" in result
        assert result["accessToken"] == "new_access_token"
        
        mock_token_tools.refresh_access_token.assert_called_once_with("valid_refresh_token")
        
        auth_service.logger.info.assert_any_call("Refresh token request received")
        auth_service.logger.info.assert_any_call("Access token refreshed successfully")

    @pytest.mark.asyncio
    async def test_refresh_token_invalid(
        self, auth_service, mock_request, mock_token_tools
    ):
        refresh_data = models.RefreshTokenRequest(refreshToken="invalid_token")
        mock_token_tools.refresh_access_token.side_effect = ValueError("Invalid refresh token")

        with pytest.raises(ValueError):
            await auth_service.refresh_token(
                mock_request, refresh_data, mock_token_tools
            )

    @pytest.mark.asyncio
    async def test_logout_success(
        self, auth_service, mock_request, mock_token_tools
    ):
        valid_token = "valid_jwt_token"

        result = await auth_service.logout(
            mock_request, valid_token, mock_token_tools
        )

        assert result is None
        
        mock_token_tools.validate_token.assert_called_once_with(valid_token)
        
        auth_service.logger.info.assert_called_once_with("User logged out successfully")

    @pytest.mark.asyncio
    async def test_logout_invalid_token(
        self, auth_service, mock_request, mock_token_tools
    ):
        invalid_token = "invalid_jwt_token"
        mock_token_tools.validate_token.return_value = False

        result = await auth_service.logout(
            mock_request, invalid_token, mock_token_tools
        )

        assert isinstance(result, JSONResponse)
        assert result.status_code == 401
        
        mock_token_tools.validate_token.assert_called_once_with(invalid_token)

    @pytest.mark.asyncio
    async def test_get_current_user_success(
        self, auth_service, mock_request, mock_token_tools
    ):
        valid_token = "valid_jwt_token"

        result = await auth_service.get_current_user(
            mock_request, valid_token, mock_token_tools
        )

        assert isinstance(result, models.UserResponse)
        assert result.id == "user_123"
        assert result.email == "test@example.com"
        assert result.name == "Test User"
        
        mock_token_tools.validate_token.assert_called_once_with(valid_token)
        mock_token_tools.get_token_payload.assert_called_once_with(valid_token)
        
        auth_service.logger.info.assert_called_once_with("User profile retrieved: test@example.com")

    @pytest.mark.asyncio
    async def test_get_current_user_invalid_token(
        self, auth_service, mock_request, mock_token_tools
    ):
        invalid_token = "invalid_jwt_token"
        mock_token_tools.validate_token.return_value = False

        result = await auth_service.get_current_user(
            mock_request, invalid_token, mock_token_tools
        )

        assert isinstance(result, JSONResponse)
        assert result.status_code == 401

    @pytest.mark.asyncio
    async def test_get_current_user_invalid_payload(
        self, auth_service, mock_request, mock_token_tools
    ):
        valid_token = "valid_jwt_token"
        mock_token_tools.get_token_payload.return_value = {
            "user_id": None,
            "email": "test@example.com",
            "name": "Test User"
        }

        result = await auth_service.get_current_user(
            mock_request, valid_token, mock_token_tools
        )

        assert isinstance(result, JSONResponse)
        assert result.status_code == 401

    @pytest.mark.asyncio
    async def test_service_initialization(self, mock_logger):
        service = AuthService(logger=mock_logger)

        assert service.logger == mock_logger

    @pytest.mark.asyncio
    async def test_login_user_password_hashing_called(
        self, auth_service, mock_request, mock_password_tools, mock_token_tools
    ):
        login_data = models.LoginRequest(
            email="test@example.com",
            password="CorrectPassword123!"
        )

        await auth_service.login_user(
            mock_request, login_data, mock_password_tools, mock_token_tools
        )

        mock_password_tools.encode_password.assert_called_with("CorrectPassword123!")

============================================================
FILE: .\tests\test_auth_tools.py
============================================================

import pytest
from authentication.tools import PasswordTools, TokenTools
from datetime import datetime, timedelta
import jwt

class TestPasswordTools:
    def setup_method(self):
        self.password_tools = PasswordTools()

    def test_encode_password_valid(self):
        password = "securepassword123"
        hashed = self.password_tools.encode_password(password)
        
        assert hashed is not None
        assert isinstance(hashed, str)
        assert hashed != password

    def test_encode_password_none(self):
        with pytest.raises(ValueError, match="password cannot be None"):
            self.password_tools.encode_password(None)

    def test_verify_password_correct(self):
        password = "securepassword123"
        hashed = self.password_tools.encode_password(password)
        
        assert self.password_tools.verify_password(password, hashed) is True

    def test_verify_password_incorrect(self):
        password = "securepassword123"
        wrong_password = "wrongpassword"
        hashed = self.password_tools.encode_password(password)
        
        assert self.password_tools.verify_password(wrong_password, hashed) is False

    def test_verify_password_none_password(self):
        with pytest.raises(ValueError, match="password cannot be None"):
            self.password_tools.verify_password(None, "somehash")

    def test_verify_password_invalid_hash(self):
        with pytest.raises(ValueError, match="Invalid hashed password"):
            self.password_tools.verify_password("password", "")

    def test_verify_password_malformed_hash(self):
        with pytest.raises(ValueError, match="Invalid hashed password format"):
            self.password_tools.verify_password("password", "invalid_hash_format")


class TestTokenTools:
    def setup_method(self):
        self.token_tools = TokenTools()
        self.sample_payload = {"user_id": 123, "username": "testuser"}

    def test_create_access_token_valid(self):
        token = self.token_tools.create_access_token(self.sample_payload)
        
        assert token is not None
        assert isinstance(token, str)

    def test_create_access_token_none_payload(self):
        with pytest.raises(ValueError, match="user data cannot be None"):
            self.token_tools.create_access_token(None)

    def test_create_refresh_token_valid(self):
        token = self.token_tools.create_refresh_token(self.sample_payload)
        
        assert token is not None
        assert isinstance(token, str)

    def test_validate_token_valid_access(self):
        token = self.token_tools.create_access_token(self.sample_payload)
        assert self.token_tools.validate_token(token, "access") is True

    def test_validate_token_valid_refresh(self):
        token = self.token_tools.create_refresh_token(self.sample_payload)
        assert self.token_tools.validate_token(token, "refresh") is True

    def test_validate_token_wrong_type(self):
        token = self.token_tools.create_access_token(self.sample_payload)
        assert self.token_tools.validate_token(token, "refresh") is False

    def test_validate_token_none(self):
        with pytest.raises(ValueError, match="Token cannot be None"):
            self.token_tools.validate_token(None)

    def test_validate_token_invalid(self):
        assert self.token_tools.validate_token("invalid_token") is False

    def test_get_token_payload_valid(self):
        token = self.token_tools.create_access_token(self.sample_payload)
        payload = self.token_tools.get_token_payload(token)
        
        assert payload == self.sample_payload
        assert "expiration" not in payload
        assert "issued_at" not in payload
        assert "type" not in payload

    def test_get_token_payload_none(self):
        with pytest.raises(ValueError, match="Token cannot be None"):
            self.token_tools.get_token_payload(None)

    def test_get_token_payload_empty(self):
        with pytest.raises(ValueError, match="Token cannot be empty"):
            self.token_tools.get_token_payload("")

    def test_get_token_payload_expired(self):
        # Create an expired token manually
        expired_time = datetime.now() - timedelta(hours=1)
        issued_time = datetime.now() - timedelta(hours=2)
    
        expired_payload = {
            **self.sample_payload,
            'expiration': expired_time.timestamp(),
            'issued_at': issued_time.timestamp(),
            'type': 'access'
        }
        expired_token = jwt.encode(expired_payload, 'random-secret-key', 'HS256')
        
        with pytest.raises(ValueError, match="Token has expired"):
            self.token_tools.get_token_payload(expired_token)

    def test_refresh_access_token_valid(self):
        refresh_token = self.token_tools.create_refresh_token(self.sample_payload)
        new_access_token = self.token_tools.refresh_access_token(refresh_token)
        
        assert new_access_token is not None
        assert isinstance(new_access_token, str)
        assert self.token_tools.validate_token(new_access_token, "access") is True

    def test_refresh_access_token_empty(self):
        with pytest.raises(ValueError, match="Refresh token cannot be empty"):
            self.token_tools.refresh_access_token("")

    def test_refresh_access_token_invalid(self):
        with pytest.raises(ValueError, match="Invalid or expired refresh token"):
            self.token_tools.refresh_access_token("invalid_token")

    def test_refresh_access_token_wrong_type(self):
        access_token = self.token_tools.create_access_token(self.sample_payload)
        with pytest.raises(ValueError, match="Invalid or expired refresh token"):
            self.token_tools.refresh_access_token(access_token)

    def test_token_payload_structure(self):
        token = self.token_tools.create_access_token(self.sample_payload)
        decoded = jwt.decode(token, 'random-secret-key', 'HS256')
        
        assert 'expiration' in decoded
        assert 'issued_at' in decoded
        assert 'type' in decoded
        assert decoded['type'] == 'access'
        assert decoded['user_id'] == 123
        assert decoded['username'] == 'testuser'
