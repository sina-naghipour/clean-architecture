Directory Bundle - 2025-12-03 00:43:43.167423
Directory: D:\codes\work\clean-architecture\clean-architecture\api\products\app
============================================================


========================================
File: bundl.py
========================================

#!/usr/bin/env python3
"""
Simple Directory Bundler
"""

import os
from pathlib import Path
from datetime import datetime

def create_bundle():
    """Create a text bundle of all text files in current directory"""
    current_dir = Path.cwd()
    output_file = current_dir / "directory_bundle.txt"
    
    print(f"Creating bundle of: {current_dir}")
    
    with open(output_file, 'w', encoding='utf-8') as bundle:
        # Write header
        bundle.write(f"Directory Bundle - {datetime.now()}\n")
        bundle.write(f"Directory: {current_dir}\n")
        bundle.write("=" * 60 + "\n\n")
        
        # Walk through directory
        file_count = 0
        
        for root, dirs, files in os.walk(current_dir):
            # Skip common directories
            dirs[:] = [d for d in dirs if d not in ['__pycache__', 'docs', 'static', '.git', '.venv', 'venv']]
            
            for file in files:
                file_path = Path(root) / file
                
                # Skip some file types
                if file_path.suffix in ['.pyc', '.pyo', '.so']:
                    continue
                
                # Skip hidden files
                if file.startswith('.'):
                    continue
                
                try:
                    # Write file header
                    bundle.write(f"\n{'='*40}\n")
                    bundle.write(f"File: {file_path.relative_to(current_dir)}\n")
                    bundle.write(f"{'='*40}\n\n")
                    
                    # Try to read and write file content
                    try:
                        with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                            content = f.read()
                            bundle.write(content)
                            if not content.endswith('\n'):
                                bundle.write('\n')
                        file_count += 1
                    except:
                        bundle.write("[Binary or unreadable file]\n")
                        
                except Exception as e:
                    bundle.write(f"[Error: {str(e)}]\n")
        
        # Write footer
        bundle.write(f"\n{'='*60}\n")
        bundle.write(f"Total files included: {file_count}\n")
        bundle.write(f"Bundle created: {datetime.now()}\n")
    
    print(f"✓ Bundle created: {output_file}")
    print(f"✓ Files included: {file_count}")

if __name__ == "__main__":
    create_bundle()

========================================
File: directory_bundle.txt
========================================



========================================
File: main.py
========================================

from fastapi import FastAPI, Request
from fastapi.responses import JSONResponse
from fastapi.middleware.cors import CORSMiddleware
import logging
import uvicorn
from contextlib import asynccontextmanager
import os
from dotenv import load_dotenv

# Load environment variables
load_dotenv()

from routes.product_routes import router as product_router
from routes.image_routes import router as image_router

# Environment variables with defaults
HOST = os.getenv('HOST', '0.0.0.0')
PORT = int(os.getenv('PORT', '8001'))
RELOAD = os.getenv('RELOAD', 'True').lower() == 'true'
LOG_LEVEL = os.getenv('LOG_LEVEL', 'info')
ENVIRONMENT = os.getenv('ENVIRONMENT', 'development')
CORS_ORIGINS = os.getenv('CORS_ORIGINS', 'http://localhost:3000,http://127.0.0.1:3000')
LOG_FILE = os.getenv('LOG_FILE', 'product_service.log')

ALLOWED_ORIGINS = [origin.strip() for origin in CORS_ORIGINS.split(',')]

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler(LOG_FILE)
    ]
)

logger = logging.getLogger(__name__)

@asynccontextmanager
async def lifespan(app: FastAPI):
    logger.info("Starting Product Service...")
    logger.info(f"Environment: {ENVIRONMENT}")
    logger.info(f"Host: {HOST}, Port: {PORT}")
    
    yield
    
    logger.info("Shutting down Product Service...")

app = FastAPI(
    title="Ecommerce API - Product Service",
    description="Product catalog microservice for Ecommerce API",
    version="1.0.0",
    docs_url="/docs",
    redoc_url="/redoc",
    openapi_url="/openapi.json",
    lifespan=lifespan
)

app.add_middleware(
    CORSMiddleware,
    allow_origins=ALLOWED_ORIGINS,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

@app.exception_handler(Exception)
async def global_exception_handler(request: Request, exc: Exception):
    logger.error(f"Global exception handler: {str(exc)}", exc_info=True)
    return JSONResponse(
        status_code=500,
        content={
            "type": "https://example.com/errors/internal",
            "title": "Internal Server Error",
            "status": 500,
            "detail": "An unexpected error occurred",
            "instance": str(request.url)
        },
        media_type="application/problem+json"
    )

@app.get("/health", tags=["Health"])
async def health_check():
    return {
        "status": "healthy",
        "service": "product",
        "timestamp": "2024-01-01T00:00:00Z",
        "environment": ENVIRONMENT
    }

@app.get("/info", tags=["Root"])
async def root():
    return {
        "message": "Ecommerce Product Service",
        "version": "1.0.0",
        "environment": ENVIRONMENT,
        "docs": "/docs",
        "health": "/health"
    }

app.include_router(product_router)
app.include_router(image_router)
if __name__ == "__main__":
    uvicorn.run(
        "main:app",
        host=HOST,
        port=PORT,
        reload=RELOAD,
        log_level=LOG_LEVEL
    )

========================================
File: pytest.ini
========================================

[pytest]
pythonpath = 
    ./
testpaths = ./tests
python_files = test_*.py
python_classes = Test*
python_functions = test_*
addopts = 
    -v
    --tb=short
    --strict-markers
    --strict-config
    --disable-warnings
markers =
    slow: marks tests as slow (deselect with '-m "not slow"')
    integration: marks tests as integration tests
    unit: marks tests as unit tests
asyncio_mode = auto
========================================
File: commands\generate_data.py
========================================

import asyncio
import aiohttp
import random
import json
from typing import List

async def create_product(session: aiohttp.ClientSession, product_data: dict):
    url = "http://localhost/api/products/create"
    try:
        async with session.post(url, json=product_data) as response:
            if response.status == 201:
                print(f"✓ Created: {product_data['name']}")
            else:
                print(f"✗ Failed: {product_data['name']} - Status: {response.status}")
                error_text = await response.text()
                print(f"  Error: {error_text}")
    except Exception as e:
        print(f"✗ Exception: {product_data['name']} - {e}")

async def generate_and_upload_products():
    categories = {
        "electronics": ["Laptop", "Smartphone", "Tablet", "Headphones", "Monitor", "Keyboard", "Mouse", "Speaker"],
        "clothing": ["T-Shirt", "Jeans", "Jacket", "Shoes", "Hat", "Dress", "Sweater", "Shorts"],
        "home": ["Chair", "Desk", "Lamp", "Rug", "Curtains", "Pillow", "Blanket", "Mirror"],
        "books": ["Novel", "Textbook", "Cookbook", "Biography", "Mystery", "Fantasy", "Science", "History"],
        "sports": ["Basketball", "Football", "Tennis Racket", "Yoga Mat", "Dumbbells", "Running Shoes", "Bicycle"]
    }
    
    brands = ["Nike", "Samsung", "Apple", "Sony", "Adidas", "Dell", "HP", "Lenovo", "Microsoft", "Google"]
    
    products = []
    
    for i in range(1000):
        category = random.choice(list(categories.keys()))
        product_type = random.choice(categories[category])
        brand = random.choice(brands)
        
        product_data = {
            "name": f"{brand} {product_type} {i:04d}",
            "price": round(random.uniform(10.0, 1000.0), 2),
            "stock": random.randint(0, 200),
            "description": f"High-quality {product_type.lower()} from {brand}. Perfect for everyday use."
        }
        products.append(product_data)
    
    # Upload products concurrently
    async with aiohttp.ClientSession() as session:
        tasks = [create_product(session, product) for product in products]
        await asyncio.gather(*tasks, return_exceptions=True)

if __name__ == "__main__":
    print("Generating and uploading 1000 test products...")
    asyncio.run(generate_and_upload_products())
    print("Finished uploading products!")

========================================
File: commands\__init__.py
========================================



========================================
File: database\connection.py
========================================

from motor.motor_asyncio import AsyncIOMotorClient
from pymongo.errors import ConnectionFailure, ServerSelectionTimeoutError
import os
import logging
from .database_models import ProductDB, ImageDB

logger = logging.getLogger(__name__)

class MongoDBConnection:
    def __init__(self):
        self.client = None
        self.db = None
        self.logger = logger.getChild("MongoDBConnection")
        
    async def connect(self, connection_string: str = None, db_name: str = None):
        try:
            connection_string = connection_string or os.getenv(
                "MONGODB_URI", "mongodb://mongodb:27017/"
            )
            db_name = db_name or os.getenv("MONGODB_DB_NAME", "product_db")
            
            self.logger.info(f"Connecting to MongoDB: {db_name}")
            self.logger.debug(f"Connection string: {self._mask_connection_string(connection_string)}")
            
            self.client = AsyncIOMotorClient(connection_string, serverSelectionTimeoutMS=5000)
            self.db = self.client[db_name]
            
            await self.client.admin.command('ping')
            self.logger.info("Successfully connected to MongoDB")
            
            await self._setup_indexes()
            
        except (ConnectionFailure, ServerSelectionTimeoutError) as e:
            self.logger.error(f"MongoDB connection failed: {e}")
            raise
        except Exception as e:
            self.logger.error(f"Unexpected error during MongoDB connection: {e}")
            raise

    def _mask_connection_string(self, connection_string: str) -> str:
        if "@" in connection_string:
            parts = connection_string.split("@")
            if len(parts) == 2:
                user_pass = parts[0]
                if "://" in user_pass:
                    protocol, credentials = user_pass.split("://", 1)
                    if ":" in credentials:
                        user, _ = credentials.split(":", 1)
                        return f"{protocol}://{user}:****@{parts[1]}"
        return connection_string

    async def _setup_indexes(self):
        try:
            product_collection = self.db[ProductDB.COLLECTION_NAME]
            product_indexes = ProductDB.get_indexes()
            
            if product_indexes:
                for index_spec in product_indexes:
                    if isinstance(index_spec, dict):
                        keys = index_spec.get('key', [])
                        options = {k: v for k, v in index_spec.items() if k != 'key'}
                        await product_collection.create_index(keys, **options)
                    elif isinstance(index_spec, (list, tuple)):
                        await product_collection.create_index(index_spec)
                    else:
                        self.logger.warning(f"Unsupported index format: {index_spec}")
                
                self.logger.info(f"Database indexes created/verified for collection: {ProductDB.COLLECTION_NAME}")
            
            image_collection = self.db[ImageDB.COLLECTION_NAME]
            image_indexes = ImageDB.get_indexes()
            
            if image_indexes:
                for index_spec in image_indexes:
                    if isinstance(index_spec, dict):
                        keys = index_spec.get('key', [])
                        options = {k: v for k, v in index_spec.items() if k != 'key'}
                        await image_collection.create_index(keys, **options)
                    elif isinstance(index_spec, (list, tuple)):
                        await image_collection.create_index(index_spec)
                    else:
                        self.logger.warning(f"Unsupported index format: {index_spec}")
                
                self.logger.info(f"Database indexes created/verified for collection: {ImageDB.COLLECTION_NAME}")
                
        except Exception as e:
            self.logger.error(f"Index creation failed: {e}")
            raise

    def get_collection(self, collection_name: str = None):
        if self.db is None:
            self.logger.error("Attempted to get collection without active database connection")
            raise Exception("Database not connected. Call connect() first.")
        
        collection_name = collection_name or ProductDB.COLLECTION_NAME
        self.logger.debug(f"Accessing collection: {collection_name}")
        return self.db[collection_name]

    def get_images_collection(self):
        if self.db is None:
            self.logger.error("Attempted to get images collection without active database connection")
            raise Exception("Database not connected. Call connect() first.")
        
        self.logger.debug(f"Accessing collection: {ImageDB.COLLECTION_NAME}")
        return self.db[ImageDB.COLLECTION_NAME]

    async def close(self):
        if self.client:
            self.client.close()
            self.logger.info("MongoDB connection closed")
        else:
            self.logger.debug("No active MongoDB connection to close")

db_connection = MongoDBConnection()

async def get_db():
    if db_connection.db is None:
        await db_connection.connect()
    return db_connection.db

async def get_products_collection():
    db = await get_db()
    collection = db[ProductDB.COLLECTION_NAME]
    logger.debug("Products collection retrieved")
    return collection

async def get_images_collection():
    db = await get_db()
    collection = db[ImageDB.COLLECTION_NAME]
    logger.debug("Images collection retrieved")
    return collection

========================================
File: database\database_models.py
========================================

from pymongo import IndexModel, ASCENDING, TEXT, DESCENDING
from datetime import datetime
import uuid
from typing import List, Optional

class ProductDB:
    def __init__(
        self,
        name: str,
        price: float,
        stock: int,
        description: str = None,
        tags: List[str] = None,
        image_ids: List[str] = None,
        primary_image_id: str = None,
        id: str = None,
        created_at: datetime = None,
        updated_at: datetime = None
    ):
        self.id = id or str(uuid.uuid4())
        self.name = name
        self.price = price
        self.stock = stock
        self.description = description
        self.tags = tags or []
        self.image_ids = image_ids or []
        self.primary_image_id = primary_image_id
        self.created_at = created_at or datetime.utcnow()
        self.updated_at = updated_at or datetime.utcnow()

    def to_dict(self):
        return {
            "_id": self.id,
            "name": self.name,
            "price": self.price,
            "stock": self.stock,
            "description": self.description,
            "tags": self.tags,
            "image_ids": self.image_ids,
            "primary_image_id": self.primary_image_id,
            "created_at": self.created_at,
            "updated_at": self.updated_at
        }

    @classmethod
    def from_dict(cls, data):
        if not data:
            return None
        return cls(
            id=data.get("_id"),
            name=data["name"],
            price=data["price"],
            stock=data["stock"],
            description=data.get("description"),
            tags=data.get("tags", []),
            image_ids=data.get("image_ids", []),
            primary_image_id=data.get("primary_image_id"),
            created_at=data.get("created_at"),
            updated_at=data.get("updated_at")
        )

    COLLECTION_NAME = "products"
    
    @classmethod
    def get_indexes(cls):
        return [
            IndexModel([("name", ASCENDING)]),
            IndexModel([("name", TEXT)]),
            IndexModel([("price", ASCENDING)]),
            IndexModel([("stock", ASCENDING)]),
            IndexModel([("created_at", DESCENDING)]),
            IndexModel([("tags", ASCENDING)]),
            IndexModel([("image_ids", ASCENDING)])
        ]


class ImageDB:
    def __init__(
        self,
        product_id: str,
        filename: str,
        original_name: str,
        mime_type: str,
        size: int,
        width: int,
        height: int,
        is_primary: bool = False,
        id: str = None,
        uploaded_at: datetime = None
    ):
        self.id = id or str(uuid.uuid4())
        self.product_id = product_id
        self.filename = filename
        self.original_name = original_name
        self.mime_type = mime_type
        self.size = size
        self.width = width
        self.height = height
        self.is_primary = is_primary
        self.uploaded_at = uploaded_at or datetime.utcnow()

    def to_dict(self):
        return {
            "_id": self.id,
            "product_id": self.product_id,
            "filename": self.filename,
            "original_name": self.original_name,
            "mime_type": self.mime_type,
            "size": self.size,
            "width": self.width,
            "height": self.height,
            "is_primary": self.is_primary,
            "uploaded_at": self.uploaded_at
        }

    @classmethod
    def from_dict(cls, data):
        if not data:
            return None
        return cls(
            id=data.get("_id"),
            product_id=data["product_id"],
            filename=data["filename"],
            original_name=data["original_name"],
            mime_type=data["mime_type"],
            size=data["size"],
            width=data["width"],
            height=data["height"],
            is_primary=data.get("is_primary", False),
            uploaded_at=data.get("uploaded_at")
        )

    COLLECTION_NAME = "product_images"
    
    @classmethod
    def get_indexes(cls):
        return [
            IndexModel([("product_id", ASCENDING)]),
            IndexModel([("is_primary", ASCENDING)]),
            IndexModel([("uploaded_at", DESCENDING)]),
            IndexModel([("mime_type", ASCENDING)]),
            IndexModel([("product_id", ASCENDING), ("is_primary", ASCENDING)])
        ]

========================================
File: database\pydantic_models.py
========================================

from pydantic import BaseModel, Field, field_validator, ConfigDict
from typing import Optional, List
from datetime import datetime


class ProductImageUpload(BaseModel):
    is_primary: bool = Field(False, description="Set as primary product image")


class ProductImage(BaseModel):
    id: str = Field(..., description="Image UUID")
    product_id: str = Field(..., description="Associated product ID")
    filename: str = Field(..., description="Server-generated filename")
    original_name: str = Field(..., description="Original client filename")
    mime_type: str = Field(..., description="Image MIME type", enum=["image/jpeg", "image/png", "image/webp"])
    size: int = Field(..., ge=1, description="File size in bytes")
    width: int = Field(..., ge=1, description="Image width in pixels")
    height: int = Field(..., ge=1, description="Image height in pixels")
    is_primary: bool = Field(..., description="Whether this is the primary product image")
    url: str = Field(..., description="Public URL to access the image")
    uploaded_at: datetime = Field(..., description="Upload timestamp")

    model_config = ConfigDict(from_attributes=True)


class ProductImageList(BaseModel):
    items: List[ProductImage]
    total: int


class PrimaryImageUpdate(BaseModel):
    image_id: str = Field(..., description="Image ID to set as primary")


class ProductImageBatchUpload(BaseModel):
    make_primary_first: bool = Field(False, description="Make first uploaded image primary")

class ProductImageBatchResponse(BaseModel):
    success: List[ProductImage] = Field(..., description="Successfully uploaded images")
    failed: List[dict] = Field(default_factory=list, description="Failed uploads with reasons")
    total: int = Field(..., description="Total files attempted")
    successful_count: int = Field(..., description="Number of successful uploads")

class ProductRequest(BaseModel):
    name: str = Field(..., min_length=1, max_length=255, description="Product name is required")
    price: float = Field(..., gt=0, description="Price must be greater than 0")
    stock: int = Field(..., ge=0, description="Stock cannot be negative")
    description: Optional[str] = Field(None, max_length=1000, description="Description cannot exceed 1000 characters")

    @field_validator('name')
    def name_not_empty(cls, v):
        if not v or not v.strip():
            raise ValueError('Product name cannot be empty')
        return v.strip()


class ProductPatch(BaseModel):
    name: Optional[str] = Field(None, min_length=1, max_length=255)
    price: Optional[float] = Field(None, gt=0)
    stock: Optional[int] = Field(None, ge=0)
    description: Optional[str] = Field(None, max_length=1000)

    @field_validator('*', mode='before')
    def empty_string_to_none(cls, v):
        if v == "":
            return None
        return v


class ProductResponse(BaseModel):
    id: str
    name: str
    price: float
    stock: int
    description: Optional[str]
    images: List['ProductImage'] = Field(default_factory=list)
    primary_image_id: Optional[str] = None

    model_config = ConfigDict(from_attributes=True)


class ProductList(BaseModel):
    items: List[ProductResponse]
    total: int
    page: int
    page_size: int


class InventoryUpdate(BaseModel):
    stock: int = Field(..., ge=0, description="Stock cannot be negative")


class ProductQueryParams(BaseModel):
    page: int = Field(1, ge=1, description="Page number must be positive")
    page_size: int = Field(20, ge=1, le=100, description="Page size must be between 1 and 100")
    q: Optional[str] = Field(None, description="Search query")


class InventoryResponse(BaseModel):
    id: str
    stock: int


class ErrorResponse(BaseModel):
    type: str
    title: str
    status: int
    detail: str
    instance: Optional[str] = None


========================================
File: database\__init__.py
========================================



========================================
File: decorators\image_routes_decorators.py
========================================

from functools import wraps
from fastapi import HTTPException
import logging

logger = logging.getLogger(__name__)

class ImageErrorDecorators:
    @staticmethod
    def handle_upload_errors(func):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            try:
                return await func(*args, **kwargs)
            except HTTPException as he:
                # Add 404 to the list of status codes that should be passed through
                if he.status_code in [400, 404, 413, 415]:
                    raise
                logger.error(f"Upload error: {he}")
                raise HTTPException(status_code=500, detail="Internal server error")
            except Exception as e:
                logger.error(f"Upload exception: {e}")
                raise HTTPException(status_code=500, detail="Internal server error")
        return wrapper

    @staticmethod
    def handle_batch_upload_errors(func):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            try:
                return await func(*args, **kwargs)
            except HTTPException as he:
                if he.status_code in [400, 404, 413, 415]:
                    raise
                
                if he.status_code == 207:
                    raise
                
                logger.error(f"Batch upload HTTP error: {he}")
                raise HTTPException(
                    status_code=500, 
                    detail="Internal server error during batch upload"
                )
            except ValueError as ve:
                logger.error(f"Batch upload validation error: {ve}")
                raise HTTPException(status_code=400, detail=str(ve))
            except Exception as e:
                logger.error(f"Batch upload unexpected error: {e}")
                raise HTTPException(
                    status_code=500,
                    detail="Failed to process batch upload request"
                )
        return wrapper

    @staticmethod
    def handle_list_errors(func):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            try:
                return await func(*args, **kwargs)
            except HTTPException:
                raise
            except Exception as e:
                logger.error(f"List images error: {e}")
                raise HTTPException(status_code=500, detail="Internal server error")
        return wrapper

    @staticmethod
    def handle_get_errors(func):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            try:
                return await func(*args, **kwargs)
            except HTTPException:
                raise
            except Exception as e:
                logger.error(f"Get image error: {e}")
                raise HTTPException(status_code=500, detail="Internal server error")
        return wrapper

    @staticmethod
    def handle_delete_errors(func):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            try:
                return await func(*args, **kwargs)
            except HTTPException:
                raise
            except Exception as e:
                logger.error(f"Delete image error: {e}")
                raise HTTPException(status_code=500, detail="Internal server error")
        return wrapper

    @staticmethod
    def handle_primary_errors(func):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            try:
                return await func(*args, **kwargs)
            except HTTPException:
                raise
            except Exception as e:
                logger.error(f"Set primary image error: {e}")
                raise HTTPException(status_code=500, detail="Internal server error")
        return wrapper

========================================
File: decorators\product_image_repository_decorators.py
========================================

import logging
from functools import wraps
from typing import Callable, Any, TypeVar, Coroutine
from motor.motor_asyncio import AsyncIOMotorCollection

logger = logging.getLogger(__name__)

C = TypeVar('C', bound=Callable[..., Coroutine[Any, Any, Any]])


def handle_repository_errors(func: C) -> C:
    @wraps(func)
    async def wrapper(*args, **kwargs):
        try:
            return await func(*args, **kwargs)
        except Exception as e:
            logger.error(f"Repository error in {func.__name__}: {e}", exc_info=True)
            raise
    return wrapper


def ensure_collection(func: C) -> C:
    @wraps(func)
    async def wrapper(self, *args, **kwargs):
        if self.collection is None:
            self.collection = await self._get_collection()
        return await func(self, *args, **kwargs)
    return wrapper


def log_operation(operation_name: str = None):
    def decorator(func: C) -> C:
        @wraps(func)
        async def wrapper(self, *args, **kwargs):
            name = operation_name or func.__name__
            self.logger.info(f"Starting {name} with args: {args}, kwargs: {kwargs}")
            try:
                result = await func(self, *args, **kwargs)
                self.logger.info(f"Completed {name} successfully")
                return result
            except Exception as e:
                self.logger.error(f"Failed {name}: {e}")
                raise
        return wrapper
    return decorator


def validate_image_id(func: C) -> C:
    @wraps(func)
    async def wrapper(self, image_id: str, *args, **kwargs):
        print('Image_ID : ', image_id, '*args :', args)
        if not isinstance(image_id, str) or image_id.strip() == "":
            raise ValueError("Invalid image ID")
        return await func(self, image_id, *args, **kwargs)
    return wrapper


def validate_image_id_set_primary_image(func: C) -> C:
    @wraps(func)
    async def wrapper(self, product_id: str, image_id: str, *args, **kwargs):
        print('Image_ID : ', image_id, '*args :', args)
        if not isinstance(image_id, str) or image_id.strip() == "":
            raise ValueError("Invalid image ID")
        return await func(self, product_id, image_id, *args, **kwargs)
    return wrapper


def validate_product_id(func: C) -> C:
    @wraps(func)
    async def wrapper(self, product_id: str, *args, **kwargs):
        if not isinstance(product_id, str) or product_id.strip() == "":
            raise ValueError("Invalid product ID")
        return await func(self, product_id, *args, **kwargs)
    return wrapper

def validate_product_id_set_primary_image(func: C) -> C:
    @wraps(func)
    async def wrapper(self, product_id: str, image_id: str, *args, **kwargs):
        if not isinstance(product_id, str) or product_id.strip() == "":
            raise ValueError("Invalid product ID")
        return await func(self, product_id, image_id, *args, **kwargs)
    return wrapper



def transaction_safe(func: C) -> C:
    @wraps(func)
    async def wrapper(self, *args, **kwargs):
        try:
            return await func(self, *args, **kwargs)
        except Exception as e:
            if hasattr(self, 'session'):
                await self.session.abort_transaction()
            raise
    return wrapper

========================================
File: decorators\product_image_service_decorators.py
========================================

import logging
from functools import wraps
from typing import Callable, Any, TypeVar, Coroutine
from fastapi import HTTPException

logger = logging.getLogger(__name__)

F = TypeVar('F', bound=Callable[..., Any])
C = TypeVar('C', bound=Callable[..., Coroutine[Any, Any, Any]])


def handle_image_errors(func: C) -> C:
    @wraps(func)
    async def wrapper(*args, **kwargs):
        try:
            return await func(*args, **kwargs)
        except HTTPException:
            raise
        except Exception as e:
            logger.error(f"Error in {func.__name__}: {e}", exc_info=True)
            raise HTTPException(status_code=500, detail="Internal server error")
    return wrapper


def validate_product_exists(product_repo_attr: str = "product_repository"):
    def decorator(func: C) -> C:
        @wraps(func)
        async def wrapper(self, product_id: str, *args, **kwargs):
            product_repo = getattr(self, product_repo_attr)
            product = await product_repo.get_product_by_id(product_id)
            if not product:
                raise HTTPException(status_code=404, detail="Product not found")
            return await func(self, product_id, *args, **kwargs)
        return wrapper
    return decorator


def validate_image_exists(image_repo_attr: str = "image_repository"):
    def decorator(func: C) -> C:
        @wraps(func)
        async def wrapper(self, product_id: str, image_id: str, *args, **kwargs):
            image_repo = getattr(self, image_repo_attr)
            image = await image_repo.get_image_by_id(image_id)
            if not image or image.product_id != product_id:
                raise HTTPException(status_code=404, detail="Image not found")
            return await func(self, product_id, image_id, *args, **kwargs)
        return wrapper
    return decorator


def validate_file_size(max_size: int = 5 * 1024 * 1024):
    def decorator(func: C) -> C:
        @wraps(func)
        async def wrapper(self, product_id: str, upload_file, *args, **kwargs):
            file_content = await upload_file.read()
            await upload_file.seek(0)
            
            if len(file_content) > max_size:
                raise HTTPException(
                    status_code=413, 
                    detail=f"File size exceeds maximum allowed size of {max_size // 1024 // 1024}MB"
                )
            
            return await func(self, product_id, upload_file, *args, **kwargs)
        return wrapper
    return decorator


def validate_image_format(func: C) -> C:
    @wraps(func)
    async def wrapper(self, product_id: str, upload_file, *args, **kwargs):
        file_content = await upload_file.read()
        await upload_file.seek(0)
        
        if not self._validate_image_content(file_content):
            raise HTTPException(status_code=415, detail="Invalid image format")
        
        return await func(self, product_id, upload_file, *args, **kwargs)
    return wrapper


def validate_path_security(func: C) -> C:
    @wraps(func)
    async def wrapper(self, *args, **kwargs):
        result = await func(self, *args, **kwargs)
        
        if hasattr(result, 'file_path'):
            if not self._validate_file_path(result.file_path):
                raise HTTPException(status_code=400, detail="Invalid file path")
        
        return result
    return wrapper


def transaction_with_rollback(func: C) -> C:
    @wraps(func)
    async def wrapper(self, *args, **kwargs):
        try:
            return await func(self, *args, **kwargs)
        except Exception as e:
            if hasattr(self, 'image_repository'):
                await self.image_repository.rollback()
            if hasattr(self, 'product_repository'):
                await self.product_repository.rollback()
            raise
    return wrapper

========================================
File: decorators\product_routes_decorators.py
========================================

from functools import wraps
from fastapi import HTTPException
import logging

logger = logging.getLogger(__name__)

class ProductErrorDecorators:
    @staticmethod
    def handle_create_errors(func):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            try:
                return await func(*args, **kwargs)
            except HTTPException:
                raise
            except Exception as e:
                logger.error(f"Create product error: {e}")
                raise HTTPException(status_code=500, detail="Internal server error")
        return wrapper

    @staticmethod
    def handle_list_errors(func):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            try:
                return await func(*args, **kwargs)
            except HTTPException:
                raise
            except Exception as e:
                logger.error(f"List products error: {e}")
                raise HTTPException(status_code=500, detail="Internal server error")
        return wrapper

    @staticmethod
    def handle_get_errors(func):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            try:
                return await func(*args, **kwargs)
            except HTTPException:
                raise
            except Exception as e:
                logger.error(f"Get product error: {e}")
                raise HTTPException(status_code=500, detail="Internal server error")
        return wrapper

    @staticmethod
    def handle_update_errors(func):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            try:
                return await func(*args, **kwargs)
            except HTTPException:
                raise
            except Exception as e:
                logger.error(f"Update product error: {e}")
                raise HTTPException(status_code=500, detail="Internal server error")
        return wrapper

    @staticmethod
    def handle_patch_errors(func):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            try:
                return await func(*args, **kwargs)
            except HTTPException:
                raise
            except Exception as e:
                logger.error(f"Patch product error: {e}")
                raise HTTPException(status_code=500, detail="Internal server error")
        return wrapper

    @staticmethod
    def handle_delete_errors(func):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            try:
                return await func(*args, **kwargs)
            except HTTPException:
                raise
            except Exception as e:
                logger.error(f"Delete product error: {e}")
                raise HTTPException(status_code=500, detail="Internal server error")
        return wrapper

    @staticmethod
    def handle_inventory_errors(func):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            try:
                return await func(*args, **kwargs)
            except HTTPException:
                raise
            except Exception as e:
                logger.error(f"Update inventory error: {e}")
                raise HTTPException(status_code=500, detail="Internal server error")
        return wrapper

========================================
File: decorators\__init__.py
========================================



========================================
File: repositories\image_repository.py
========================================

from typing import List, Optional, Dict, Any
from motor.motor_asyncio import AsyncIOMotorCollection
import logging

from database.database_models import ImageDB
from database.connection import get_images_collection
from decorators.product_image_repository_decorators import (
    handle_repository_errors, ensure_collection,
    log_operation, validate_image_id, validate_product_id,
    transaction_safe, validate_image_id_set_primary_image,
    validate_product_id_set_primary_image
)

logger = logging.getLogger(__name__)

class ImageRepository:
    def __init__(self, collection: AsyncIOMotorCollection = None):
        self.collection = collection
        self.logger = logger.getChild("ImageRepository")

    async def _get_collection(self) -> AsyncIOMotorCollection:
        if self.collection is None:
            self.collection = await get_images_collection()
        return self.collection

    @handle_repository_errors
    @ensure_collection
    @log_operation("create_image")
    async def create_image(self, image_data: ImageDB) -> Optional[ImageDB]:
        image_dict = image_data.to_dict()
        result = await self.collection.insert_one(image_dict)
        
        if result.inserted_id:
            return image_data
        return None

    @handle_repository_errors
    @ensure_collection
    @log_operation("get_image_by_id")
    @validate_image_id
    async def get_image_by_id(self, image_id: str) -> Optional[ImageDB]:
        image_data = await self.collection.find_one({"_id": image_id})
        
        if image_data:
            return ImageDB.from_dict(image_data)
        return None

    @handle_repository_errors
    @ensure_collection
    @log_operation("get_images_by_product_id")
    @validate_product_id
    async def get_images_by_product_id(self, product_id: str) -> List[ImageDB]:
        cursor = self.collection.find({"product_id": product_id}).sort("uploaded_at", -1)
        images_data = await cursor.to_list(length=None)
        
        return [ImageDB.from_dict(data) for data in images_data]

    @handle_repository_errors
    @ensure_collection
    @log_operation("get_primary_image_by_product_id")
    @validate_product_id
    async def get_primary_image_by_product_id(self, product_id: str) -> Optional[ImageDB]:
        image_data = await self.collection.find_one({
            "product_id": product_id,
            "is_primary": True
        })
        
        if image_data:
            return ImageDB.from_dict(image_data)
        return None

    @handle_repository_errors
    @ensure_collection
    @log_operation("update_image")
    @validate_image_id
    async def update_image(self, image_id: str, update_data: Dict[str, Any]) -> Optional[ImageDB]:
        result = await self.collection.update_one(
            {"_id": image_id},
            {"$set": update_data}
        )
        
        if result.modified_count > 0:
            return await self.get_image_by_id(image_id)
        return await self.get_image_by_id(image_id)

    @handle_repository_errors
    @ensure_collection
    @log_operation("delete_image")
    @validate_image_id
    async def delete_image(self, image_id: str) -> bool:
        result = await self.collection.delete_one({"_id": image_id})
        return result.deleted_count > 0

    @handle_repository_errors
    @ensure_collection
    @transaction_safe
    @log_operation("set_primary_image")
    @validate_image_id_set_primary_image
    @validate_product_id_set_primary_image
    async def set_primary_image(self, product_id: str, image_id: str) -> bool:
        target_image = await self.collection.find_one({
            "_id": image_id,
            "product_id": product_id
        })
        
        if not target_image:
            return False
        
        await self.collection.update_many(
            {"product_id": product_id, "is_primary": True},
            {"$set": {"is_primary": False}}
        )
        
        result = await self.collection.update_one(
            {"_id": image_id},
            {"$set": {"is_primary": True}}
        )
        
        return result.modified_count > 0

    @handle_repository_errors
    @ensure_collection
    @log_operation("count_images_by_product_id")
    @validate_product_id
    async def count_images_by_product_id(self, product_id: str) -> int:
        count = await self.collection.count_documents({"product_id": product_id})
        return count

    @handle_repository_errors
    @ensure_collection
    @log_operation("get_recent_images")
    async def get_recent_images(self, limit: int = 20) -> List[ImageDB]:
        cursor = self.collection.find({}).sort("uploaded_at", -1).limit(limit)
        images_data = await cursor.to_list(length=limit)
        
        return [ImageDB.from_dict(data) for data in images_data]

========================================
File: repositories\product_repository.py
========================================

from typing import List, Optional, Dict, Any
from motor.motor_asyncio import AsyncIOMotorCollection
from bson import ObjectId
import logging
from datetime import datetime

from database.database_models import ProductDB
from database.connection import get_products_collection

logger = logging.getLogger(__name__)

class ProductRepository:
    def __init__(self, collection: AsyncIOMotorCollection = None):
        self.collection = collection
        self.logger = logger.getChild("ProductRepository")

    async def _get_collection(self) -> AsyncIOMotorCollection:
        if self.collection is None:
            self.collection = await get_products_collection()
        return self.collection

    async def create_product(self, product_data: ProductDB) -> Optional[ProductDB]:
        try:
            collection = await self._get_collection()
            self.logger.info(f"Creating product: {product_data.name}")
            
            existing_product = await collection.find_one({
                "name": {"$regex": f"^{product_data.name}$", "$options": "i"}
            })
            
            if existing_product:
                self.logger.warning(f"Product with name '{product_data.name}' already exists")
                return None
            
            product_dict = product_data.to_dict()
            result = await collection.insert_one(product_dict)
            
            if result.inserted_id:
                self.logger.info(f"Product created successfully with ID: {product_data.id}")
                return product_data
            else:
                self.logger.error("Failed to create product")
                return None
                
        except Exception as e:
            self.logger.error(f"Error creating product: {e}")
            raise

    async def get_product_by_id(self, product_id: str) -> Optional[ProductDB]:
        try:
            collection = await self._get_collection()
            self.logger.info(f"Fetching product by ID: {product_id}")
            
            product_data = await collection.find_one({"_id": product_id})
            
            if product_data:
                self.logger.info(f"Product found: {product_id}")
                return ProductDB.from_dict(product_data)
            else:
                self.logger.info(f"Product not found: {product_id}")
                return None
                
        except Exception as e:
            self.logger.error(f"Error fetching product {product_id}: {e}")
            raise

    async def get_product_by_name(self, name: str) -> Optional[ProductDB]:
        try:
            collection = await self._get_collection()
            self.logger.info(f"Fetching product by name: {name}")
            
            product_data = await collection.find_one({
                "name": {"$regex": f"^{name}$", "$options": "i"}
            })
            
            if product_data:
                self.logger.info(f"Product found by name: {name}")
                return ProductDB.from_dict(product_data)
            else:
                self.logger.info(f"Product not found by name: {name}")
                return None
                
        except Exception as e:
            self.logger.error(f"Error fetching product by name {name}: {e}")
            raise

    async def list_products(
        self, 
        skip: int = 0, 
        limit: int = 20,
        search_query: Optional[str] = None,
        tags: Optional[List[str]] = None
    ) -> List[ProductDB]:
        try:
            collection = await self._get_collection()
            self.logger.info(f"Listing products - skip: {skip}, limit: {limit}, search: {search_query}, tags: {tags}")
            
            query = {}
            if search_query:
                query["$or"] = [
                    {"name": {"$regex": search_query, "$options": "i"}},
                    {"description": {"$regex": search_query, "$options": "i"}}
                ]
            
            if tags:
                query["tags"] = {"$in": tags}
            
            cursor = collection.find(query).sort("created_at", -1).skip(skip).limit(limit)
            products_data = await cursor.to_list(length=limit)
            
            products = [ProductDB.from_dict(data) for data in products_data]
            self.logger.info(f"Found {len(products)} products")
            
            return products
            
        except Exception as e:
            self.logger.error(f"Error listing products: {e}")
            raise

    async def count_products(self, search_query: Optional[str] = None, tags: Optional[List[str]] = None) -> int:
        try:
            collection = await self._get_collection()
            query = {}
            if search_query:
                query["$or"] = [
                    {"name": {"$regex": search_query, "$options": "i"}},
                    {"description": {"$regex": search_query, "$options": "i"}}
                ]
            
            if tags:
                query["tags"] = {"$in": tags}
            
            count = await collection.count_documents(query)
            self.logger.debug(f"Counted {count} products")
            
            return count
            
        except Exception as e:
            self.logger.error(f"Error counting products: {e}")
            raise

    async def update_product(self, product_id: str, update_data: Dict[str, Any]) -> Optional[ProductDB]:
        try:
            collection = await self._get_collection()
            self.logger.info(f"Updating product: {product_id}")
            
            if "name" in update_data:
                existing_product = await collection.find_one({
                    "name": {"$regex": f"^{update_data['name']}$", "$options": "i"},
                    "_id": {"$ne": product_id}
                })
                
                if existing_product:
                    self.logger.warning(f"Product with name '{update_data['name']}' already exists")
                    return None
            
            update_data["updated_at"] = datetime.utcnow()
            
            result = await collection.update_one(
                {"_id": product_id},
                {"$set": update_data}
            )
            
            if result.modified_count > 0:
                self.logger.info(f"Product updated successfully: {product_id}")
                return await self.get_product_by_id(product_id)
            else:
                self.logger.info(f"No changes made to product: {product_id}")
                return await self.get_product_by_id(product_id)
                
        except Exception as e:
            self.logger.error(f"Error updating product {product_id}: {e}")
            raise

    async def delete_product(self, product_id: str) -> bool:
        try:
            collection = await self._get_collection()
            self.logger.info(f"Deleting product: {product_id}")
            
            result = await collection.delete_one({"_id": product_id})
            
            if result.deleted_count > 0:
                self.logger.info(f"Product deleted successfully: {product_id}")
                return True
            else:
                self.logger.info(f"Product not found for deletion: {product_id}")
                return False
                
        except Exception as e:
            self.logger.error(f"Error deleting product {product_id}: {e}")
            raise

    async def update_inventory(self, product_id: str, new_stock: int) -> Optional[ProductDB]:
        try:
            collection = await self._get_collection()
            self.logger.info(f"Updating inventory for product: {product_id} to stock: {new_stock}")
            
            result = await collection.update_one(
                {"_id": product_id},
                {
                    "$set": {
                        "stock": new_stock,
                        "updated_at": datetime.utcnow()
                    }
                }
            )
            
            if result.modified_count > 0:
                self.logger.info(f"Inventory updated successfully for product: {product_id}")
                return await self.get_product_by_id(product_id)
            else:
                self.logger.info(f"No inventory update made for product: {product_id}")
                return await self.get_product_by_id(product_id)
                
        except Exception as e:
            self.logger.error(f"Error updating inventory for product {product_id}: {e}")
            raise

    async def get_products_by_tags(self, tags: List[str], skip: int = 0, limit: int = 20) -> List[ProductDB]:
        try:
            collection = await self._get_collection()
            self.logger.info(f"Fetching products by tags: {tags}")
            
            cursor = collection.find(
                {"tags": {"$in": tags}}
            ).sort("created_at", -1).skip(skip).limit(limit)
            
            products_data = await cursor.to_list(length=limit)
            products = [ProductDB.from_dict(data) for data in products_data]
            
            self.logger.info(f"Found {len(products)} products with tags {tags}")
            return products
            
        except Exception as e:
            self.logger.error(f"Error fetching products by tags: {e}")
            raise

    async def get_popular_tags(self, limit: int = 10) -> List[Dict[str, Any]]:
        try:
            collection = await self._get_collection()
            self.logger.info(f"Fetching {limit} most popular tags")
            
            pipeline = [
                {"$unwind": "$tags"},
                {"$group": {"_id": "$tags", "count": {"$sum": 1}}},
                {"$sort": {"count": -1}},
                {"$limit": limit},
                {"$project": {"tag": "$_id", "count": 1, "_id": 0}}
            ]
            
            tags = await collection.aggregate(pipeline).to_list(length=limit)
            self.logger.info(f"Found {len(tags)} popular tags")
            
            return tags
            
        except Exception as e:
            self.logger.error(f"Error fetching popular tags: {e}")
            raise

    async def add_image_to_product(self, product_id: str, image_id: str) -> Optional[ProductDB]:
        try:
            collection = await self._get_collection()
            self.logger.info(f"Adding image {image_id} to product {product_id}")
            
            result = await collection.update_one(
                {"_id": product_id},
                {"$addToSet": {"image_ids": image_id}}
            )
            
            if result.modified_count > 0:
                self.logger.info(f"Image {image_id} added to product {product_id}")
                return await self.get_product_by_id(product_id)
            else:
                self.logger.info(f"Product {product_id} not found for image addition")
                return None
                
        except Exception as e:
            self.logger.error(f"Error adding image to product {product_id}: {e}")
            raise

    async def remove_image_from_product(self, product_id: str, image_id: str) -> Optional[ProductDB]:
        try:
            collection = await self._get_collection()
            self.logger.info(f"Removing image {image_id} from product {product_id}")
            
            result = await collection.update_one(
                {"_id": product_id},
                {
                    "$pull": {"image_ids": image_id},
                    "$set": {"updated_at": datetime.utcnow()}
                }
            )
            
            if result.modified_count > 0:
                self.logger.info(f"Image {image_id} removed from product {product_id}")
                product = await self.get_product_by_id(product_id)
                
                if product and product.primary_image_id == image_id:
                    await collection.update_one(
                        {"_id": product_id},
                        {"$set": {"primary_image_id": None}}
                    )
                    self.logger.info(f"Primary image cleared for product {product_id}")
                
                return await self.get_product_by_id(product_id)
            else:
                self.logger.info(f"Product {product_id} not found for image removal")
                return None
                
        except Exception as e:
            self.logger.error(f"Error removing image from product {product_id}: {e}")
            raise

    async def set_primary_image(self, product_id: str, image_id: str) -> Optional[ProductDB]:
        try:
            collection = await self._get_collection()
            self.logger.info(f"Setting primary image {image_id} for product {product_id}")
            
            result = await collection.update_one(
                {"_id": product_id, "image_ids": image_id},
                {
                    "$set": {
                        "primary_image_id": image_id,
                        "updated_at": datetime.utcnow()
                    }
                }
            )
            
            if result.modified_count > 0:
                self.logger.info(f"Primary image set to {image_id} for product {product_id}")
                return await self.get_product_by_id(product_id)
            else:
                self.logger.info(f"Product {product_id} or image {image_id} not found")
                return None
                
        except Exception as e:
            self.logger.error(f"Error setting primary image for product {product_id}: {e}")
            raise

========================================
File: repositories\__init__.py
========================================



========================================
File: routes\image_routes.py
========================================

import logging
import os
from fastapi import APIRouter, Request, Depends, UploadFile, File, Form
from services.image_services import ImageService
from database import pydantic_models
from typing import List
from decorators.image_routes_decorators import ImageErrorDecorators

logger = logging.getLogger(__name__)

router = APIRouter(prefix="/images", tags=['Product Images'])

def get_image_service() -> ImageService:
    return ImageService()

@router.post(
    '/products/{product_id}',
    response_model=pydantic_models.ProductImage,
    status_code=201,
    summary="Upload product image"
)
@ImageErrorDecorators.handle_upload_errors
async def upload_product_image(
    request: Request,
    product_id: str,
    file: UploadFile = File(...),
    is_primary: bool = Form(False),
    image_service: ImageService = Depends(get_image_service),
) -> pydantic_models.ProductImage:
    return await image_service.upload_product_image(
        product_id=product_id,
        upload_file=file,
        is_primary=is_primary
    )

@router.post(
    '/products/{product_id}/batch',
    response_model=pydantic_models.ProductImageBatchResponse,
    status_code=207,
    summary="Upload multiple product images"
)
@ImageErrorDecorators.handle_batch_upload_errors
async def upload_product_images_batch(
    request: Request,
    product_id: str,
    files: List[UploadFile] = File(...),
    make_primary_first: bool = Form(False),
    image_service: ImageService = Depends(get_image_service),
) -> pydantic_models.ProductImageBatchResponse:
    return await image_service.upload_product_images_batch(
        product_id=product_id,
        upload_files=files,
        make_primary_first=make_primary_first
    )

@router.get(
    '/products/{product_id}',
    response_model=pydantic_models.ProductImageList,
    summary="List product images"
)
@ImageErrorDecorators.handle_list_errors
async def list_product_images(
    request: Request,
    product_id: str,
    image_service: ImageService = Depends(get_image_service),
) -> pydantic_models.ProductImageList:
    images = await image_service.get_product_images(product_id)
    
    return pydantic_models.ProductImageList(
        items=images,
        total=len(images)
    )

@router.get(
    '/products/{product_id}/{image_id}',
    response_model=pydantic_models.ProductImage,
    summary="Get product image metadata"
)
@ImageErrorDecorators.handle_get_errors
async def get_product_image(
    request: Request,
    product_id: str,
    image_id: str,
    image_service: ImageService = Depends(get_image_service),
) -> pydantic_models.ProductImage:
    images = await image_service.get_product_images(product_id)
    
    for image in images:
        if image.id == image_id:
            return image
    
    from services.product_helpers import create_problem_response
    return create_problem_response(
        status_code=404,
        error_type="not-found",
        title="Not Found",
        detail="Image not found",
        instance=str(request.url)
    )

@router.delete(
    '/products/{product_id}/{image_id}',
    status_code=204,
    summary="Delete product image"
)
@ImageErrorDecorators.handle_delete_errors
async def delete_product_image(
    request: Request,
    product_id: str,
    image_id: str,
    image_service: ImageService = Depends(get_image_service),
) -> None:
    deleted = await image_service.delete_product_image(product_id, image_id)
    
    if not deleted:
        from services.product_helpers import create_problem_response
        return create_problem_response(
            status_code=404,
            error_type="not-found",
            title="Not Found",
            detail="Image not found",
            instance=str(request.url)
        )
    
    return None

@router.patch(
    '/products/{product_id}/{image_id}/primary',
    response_model=pydantic_models.ProductImage,
    summary="Set image as primary for product"
)
@ImageErrorDecorators.handle_primary_errors
async def set_primary_image(
    request: Request,
    product_id: str,
    image_id: str,
    image_service: ImageService = Depends(get_image_service),
) -> pydantic_models.ProductImage:
    return await image_service.set_primary_image(product_id, image_id)

========================================
File: routes\product_routes.py
========================================

import logging
import os
from fastapi import APIRouter, Request, Depends, Query
from services.product_services import ProductService
from database import pydantic_models
from decorators.product_routes_decorators import ProductErrorDecorators

logger = logging.getLogger(__name__)

router = APIRouter(tags=['products'])

DEFAULT_PAGE_SIZE = int(os.getenv('DEFAULT_PAGE_SIZE', '20'))
MAX_PAGE_SIZE = int(os.getenv('MAX_PAGE_SIZE', '100'))

# Dependency injection functions
def get_product_service() -> ProductService:
    return ProductService(logger=logger)

@router.post(
    '/create',
    response_model=pydantic_models.ProductResponse,
    status_code=201,
    summary="Create product"
)
@ProductErrorDecorators.handle_create_errors
async def create_product(
    request: Request,
    product_data: pydantic_models.ProductRequest,
    product_service: ProductService = Depends(get_product_service),
) -> pydantic_models.ProductResponse:
    return await product_service.create_product(request, product_data)

@router.get(
    '/',
    response_model=pydantic_models.ProductList,
    summary="List products (supports paging & filtering)"
)
@ProductErrorDecorators.handle_list_errors
async def list_products(
    request: Request,
    product_service: ProductService = Depends(get_product_service),
    page: int = Query(1, ge=1, description="Page number"),
    page_size: int = Query(DEFAULT_PAGE_SIZE, ge=1, le=MAX_PAGE_SIZE, description="Page size"),
    q: str = Query(None, description="Search query"),
) -> pydantic_models.ProductList:
    query_params = pydantic_models.ProductQueryParams(
        page=page,
        page_size=page_size,
        q=q
    )
    return await product_service.list_products(request, query_params)

@router.get(
    '/{product_id}',
    response_model=pydantic_models.ProductResponse,
    summary="Get product details"
)
@ProductErrorDecorators.handle_get_errors
async def get_product(
    request: Request,
    product_id: str,
    product_service: ProductService = Depends(get_product_service),
) -> pydantic_models.ProductResponse:
    return await product_service.get_product(request, product_id)

@router.put(
    '/{product_id}',
    response_model=pydantic_models.ProductResponse,
    summary="Replace product (full update)"
)
@ProductErrorDecorators.handle_update_errors
async def update_product(
    request: Request,
    product_id: str,
    update_data: pydantic_models.ProductRequest,
    product_service: ProductService = Depends(get_product_service),
) -> pydantic_models.ProductResponse:
    return await product_service.update_product(request, product_id, update_data)

@router.patch(
    '/{product_id}',
    response_model=pydantic_models.ProductResponse,
    summary="Partially update product"
)
@ProductErrorDecorators.handle_patch_errors
async def patch_product(
    request: Request,
    product_id: str,
    patch_data: pydantic_models.ProductPatch,
    product_service: ProductService = Depends(get_product_service),
) -> pydantic_models.ProductResponse:
    return await product_service.patch_product(request, product_id, patch_data)

@router.delete(
    '/{product_id}',
    status_code=204,
    summary="Delete product"
)
@ProductErrorDecorators.handle_delete_errors
async def delete_product(
    request: Request,
    product_id: str,
    product_service: ProductService = Depends(get_product_service),
) -> None:
    return await product_service.delete_product(request, product_id)

@router.patch(
    '/{product_id}/inventory',
    response_model=pydantic_models.InventoryResponse,
    summary="Update product stock"
)
@ProductErrorDecorators.handle_inventory_errors
async def update_inventory(
    request: Request,
    product_id: str,
    inventory_data: pydantic_models.InventoryUpdate,
    product_service: ProductService = Depends(get_product_service),
):
    return await product_service.update_inventory(request, product_id, inventory_data)

========================================
File: routes\__init__.py
========================================



========================================
File: services\image_services.py
========================================

import os
import shutil
import uuid
from typing import Optional, List
from pathlib import Path
import magic
from fastapi import UploadFile, HTTPException
import logging
from datetime import datetime

from repositories.image_repository import ImageRepository
from repositories.product_repository import ProductRepository
from database.database_models import ImageDB
from database import pydantic_models
from .metadata_generator import MetadataGenerator

logger = logging.getLogger(__name__)

class ImageService:
    def __init__(self, 
                 image_repository: Optional[ImageRepository] = None,
                 product_repository: Optional[ProductRepository] = None,
                 metadata_generator: Optional[MetadataGenerator] = None):
        self.image_repository = image_repository or ImageRepository()
        self.product_repository = product_repository or ProductRepository()
        self.metadata_generator = metadata_generator or MetadataGenerator()
        
        self.base_storage_path = Path(os.getenv("IMAGE_STORAGE_PATH", "static/img"))
        self.max_file_size = 5 * 1024 * 1024
        self.allowed_mime_types = {
            "image/jpeg": ".jpg",
            "image/png": ".png", 
            "image/webp": ".webp"
        }
        
        self.base_storage_path.mkdir(parents=True, exist_ok=True)
    
    def _validate_file_path(self, filepath: Path) -> bool:
        try:
            absolute_path = filepath.resolve()
            allowed_path = self.base_storage_path.resolve()
            
            if not str(absolute_path).startswith(str(allowed_path)):
                logger.error(f"Path traversal attempt: {filepath}")
                print('filepath-startswith: ', filepath)
                return False
            
            if ".." in str(filepath) or filepath.is_absolute():
                logger.error(f"Invalid path pattern: {filepath}")
                print('filepath-..: ', filepath)
                return False
                
            return True
            
        except Exception as e:
            logger.error(f"Path validation error: {e}")
            return False
    
    def _get_mime_type(self, file_content: bytes) -> Optional[str]:
        try:
            mime = magic.Magic(mime=True)
            return mime.from_buffer(file_content)
        except Exception as e:
            logger.error(f"MIME type detection failed: {e}")
            return None
    
    def _validate_image_content(self, file_content: bytes) -> bool:
        mime_type = self._get_mime_type(file_content)
        
        if not mime_type or mime_type not in self.allowed_mime_types:
            logger.error(f"Invalid MIME type: {mime_type}")
            return False
        
        return True
    
    def _generate_server_filename(self, product_id: str, mime_type: str) -> str:
        file_ext = self.allowed_mime_types.get(mime_type, ".jpg")
        unique_id = str(uuid.uuid4())[:8]
        return f"{product_id}_{unique_id}{file_ext}"
    
    async def upload_product_image(self, 
                                  product_id: str, 
                                  upload_file: UploadFile,
                                  is_primary: bool = False) -> Optional[pydantic_models.ProductImage]:
        
        try:
            product = await self.product_repository.get_product_by_id(product_id)
            if not product:
                logger.error(f"Product not found: {product_id}")
                raise HTTPException(status_code=404, detail="Product not found")
            
            file_content = await upload_file.read()
            
            if len(file_content) > self.max_file_size:
                logger.error(f"File too large: {len(file_content)} bytes")
                raise HTTPException(status_code=413, detail="File size exceeds maximum allowed size of 5MB")
            
            if not self._validate_image_content(file_content):
                logger.error(f"Invalid image content")
                raise HTTPException(status_code=415, detail="Invalid image format")
            
            mime_type = self._get_mime_type(file_content)
            if not mime_type:
                logger.error(f"Could not determine MIME type")
                raise HTTPException(status_code=400, detail="Could not determine file type")
            
            product_dir = self.base_storage_path / "products" / product_id
            product_dir.mkdir(parents=True, exist_ok=True)
            
            server_filename = self._generate_server_filename(product_id, mime_type)
            file_path = product_dir / server_filename
            
            if not self._validate_file_path(file_path):
                logger.error(f"Invalid file path: {file_path}")
                raise HTTPException(status_code=400, detail="Invalid file path")
            
            temp_file_path = file_path.with_suffix(".tmp")
            
            with open(temp_file_path, "wb") as f:
                f.write(file_content)
            
            os.rename(temp_file_path, file_path)
            
            from PIL import Image
            with Image.open(file_path) as img:
                width, height = img.size
            
            image_db = ImageDB(
                product_id=product_id,
                filename=server_filename,
                original_name=upload_file.filename,
                mime_type=mime_type,
                size=len(file_content),
                width=width,
                height=height,
                is_primary=is_primary
            )
            
            created_image = await self.image_repository.create_image(image_db)
            if not created_image:
                logger.error(f"Failed to save image metadata to database")
                os.remove(file_path)
                raise HTTPException(status_code=500, detail="Failed to save image")
            
            await self.product_repository.add_image_to_product(product_id, created_image.id)
            
            if is_primary:
                await self.product_repository.set_primary_image(product_id, created_image.id)
                await self.image_repository.set_primary_image(product_id, created_image.id)
            
            image_url = f"/static/img/products/{product_id}/{server_filename}"
            
            product_image = pydantic_models.ProductImage(
                id=created_image.id,
                product_id=product_id,
                filename=server_filename,
                original_name=upload_file.filename,
                mime_type=mime_type,
                size=len(file_content),
                width=width,
                height=height,
                is_primary=is_primary,
                url=image_url,
                uploaded_at=created_image.uploaded_at
            )
            
            image_metadata = {
                "id": created_image.id,
                "url": image_url,
                "is_primary": is_primary,
                "width": width,
                "height": height,
                "filename": server_filename,
                "mime_type": mime_type,
                "uploaded_at": created_image.uploaded_at.isoformat() if hasattr(created_image.uploaded_at, 'isoformat') else str(created_image.uploaded_at)
            }

            self.metadata_generator.update_product_images(
                product_id=product_id,
                product_name=product.name,
                image_data=image_metadata,
                operation="add"
            )

            return product_image
            
        except HTTPException:
            raise
        except Exception as e:
            logger.error(f"Image upload failed: {e}")
            raise HTTPException(status_code=500, detail="Internal server error")

    async def upload_product_images_batch(self, product_id: str, upload_files: List[UploadFile], make_primary_first: bool = False):
        success = []
        failed = []
        primary_set = False
        
        for upload_file in upload_files:
            try:
                is_primary = False
                if make_primary_first and not primary_set:
                    is_primary = True
                
                image = await self.upload_product_image(
                    product_id=product_id,
                    upload_file=upload_file,
                    is_primary=is_primary
                )
                
                success.append(image)
                
                if is_primary:
                    primary_set = True
                    
            except HTTPException as e:
                failed.append({
                    "filename": upload_file.filename,
                    "error": e.detail,
                    "status_code": e.status_code
                })

        return {
            "success": success,
            "failed": failed,
            "total": len(upload_files),
            "successful_count": len(success),
            "primary_image_id": success[0].id if success and make_primary_first else None
        }

    async def get_product_images(self, product_id: str) -> List[pydantic_models.ProductImage]:
        try:
            product = await self.product_repository.get_product_by_id(product_id)
            if not product:
                raise HTTPException(status_code=404, detail="Product not found")
            
            image_records = await self.image_repository.get_images_by_product_id(product_id)
            
            images = []
            for img in image_records:
                image_url = f"/static/img/products/{product_id}/{img.filename}"
                images.append(pydantic_models.ProductImage(
                    id=img.id,
                    product_id=img.product_id,
                    filename=img.filename,
                    original_name=img.original_name,
                    mime_type=img.mime_type,
                    size=img.size,
                    width=img.width,
                    height=img.height,
                    is_primary=img.is_primary,
                    url=image_url,
                    uploaded_at=img.uploaded_at
                ))
            
            return images
            
        except HTTPException:
            raise
        except Exception as e:
            logger.error(f"Failed to get product images: {e}")
            raise HTTPException(status_code=500, detail="Internal server error")
    
    async def delete_product_image(self, product_id: str, image_id: str) -> bool:
        try:
            product = await self.product_repository.get_product_by_id(product_id)
            if not product:
                raise HTTPException(status_code=404, detail="Product not found")
            
            image = await self.image_repository.get_image_by_id(image_id)
            if not image or image.product_id != product_id:
                raise HTTPException(status_code=404, detail="Image not found")
            
            file_path = self.base_storage_path / "products" / product_id / image.filename
            
            if file_path.exists():
                file_path.unlink()
            
            deleted = await self.image_repository.delete_image(image_id)
            if deleted:
                await self.product_repository.remove_image_from_product(product_id, image_id)
                
                image_metadata = {
                    "id": image_id,
                    "url": f"/static/img/products/{product_id}/{image.filename}",
                    "is_primary": image.is_primary
                }
                
                self.metadata_generator.update_product_images(
                    product_id=product_id,
                    product_name=product.name,
                    image_data=image_metadata,
                    operation="remove"
                )
            
            return deleted
            
        except HTTPException:
            raise
        except Exception as e:
            logger.error(f"Failed to delete image: {e}")
            raise HTTPException(status_code=500, detail="Internal server error")
    
    async def set_primary_image(self, product_id: str, image_id: str) -> Optional[pydantic_models.ProductImage]:
        try:
            product = await self.product_repository.get_product_by_id(product_id)
            if not product:
                raise HTTPException(status_code=404, detail="Product not found")
            
            if image_id not in product.image_ids:
                raise HTTPException(status_code=400, detail="Image does not belong to product")
            
            success = await self.image_repository.set_primary_image(product_id, image_id)
            if not success:
                raise HTTPException(status_code=400, detail="Failed to set primary image")
            
            await self.product_repository.set_primary_image(product_id, image_id)
            
            updated_image = await self.image_repository.get_image_by_id(image_id)
            
            image_url = f"/static/img/products/{product_id}/{updated_image.filename}"
            
            product_image = pydantic_models.ProductImage(
                id=updated_image.id,
                product_id=updated_image.product_id,
                filename=updated_image.filename,
                original_name=updated_image.original_name,
                mime_type=updated_image.mime_type,
                size=updated_image.size,
                width=updated_image.width,
                height=updated_image.height,
                is_primary=updated_image.is_primary,
                url=image_url,
                uploaded_at=updated_image.uploaded_at
            )
            
            image_metadata = {
                "id": image_id,
                "url": image_url,
                "is_primary": True
            }
            
            self.metadata_generator.update_product_images(
                product_id=product_id,
                product_name=product.name,
                image_data=image_metadata,
                operation="update_primary"
            )
            
            return product_image
            
        except HTTPException:
            raise
        except Exception as e:
            logger.error(f"Failed to set primary image: {e}")
            raise HTTPException(status_code=500, detail="Internal server error")
    
    def _update_docusaurus_metadata(self, product_id: str):
        try:
            metadata_file = self.base_storage_path / "metadata.json"
            
            import json
            metadata = {}
            if metadata_file.exists():
                with open(metadata_file, "r") as f:
                    metadata = json.load(f)
            
            product_images = []
            for image_id in self.product_repository.get_product_by_id(product_id).image_ids:
                image = self.image_repository.get_image_by_id(image_id)
                if image:
                    product_images.append({
                        "id": image.id,
                        "url": f"/static/img/products/{product_id}/{image.filename}",
                        "is_primary": image.is_primary,
                        "width": image.width,
                        "height": image.height
                    })
            
            metadata[product_id] = product_images
            
            temp_file = metadata_file.with_suffix(".tmp")
            with open(temp_file, "w") as f:
                json.dump(metadata, f, indent=2)
            
            os.rename(temp_file, metadata_file)
            logger.info(f"Updated Docusaurus metadata for product {product_id}")
            
        except Exception as e:
            logger.error(f"Failed to update Docusaurus metadata: {e}")

========================================
File: services\metadata_generator.py
========================================

import json
import logging
from pathlib import Path
from typing import Dict, Any, List
import os
from datetime import datetime

logger = logging.getLogger(__name__)

class MetadataGenerator:
    def __init__(self, base_storage_path: Path = None):
        self.base_storage_path = base_storage_path or Path(os.getenv("IMAGE_STORAGE_PATH", "static/img"))
        self.metadata_file = self.base_storage_path / "metadata.json"
        
        self.base_storage_path.mkdir(parents=True, exist_ok=True)
        
        if not self.metadata_file.exists():
            logger.info(f"Creating empty metadata.json at {self.metadata_file}")
            with open(self.metadata_file, 'w') as f:
                json.dump({}, f)
        else:
            try:
                with open(self.metadata_file, 'r') as f:
                    content = f.read().strip()
                    if not content:
                        logger.warning("metadata.json exists but is empty. Recreating...")
                        with open(self.metadata_file, 'w') as f:
                            json.dump({}, f)
            except Exception:
                logger.warning("metadata.json corrupted. Recreating...")
                with open(self.metadata_file, 'w') as f:
                    json.dump({}, f)

    def _read_existing_metadata(self) -> Dict[str, Any]:
        try:
            if self.metadata_file.exists():
                if self.metadata_file.stat().st_size == 0:
                    logger.warning("metadata.json is empty, returning empty dict")
                    return {}
                
                with open(self.metadata_file, 'r') as f:
                    content = f.read().strip()
                    if not content:
                        return {}
                    return json.loads(content)
            return {}
        except (json.JSONDecodeError, IOError) as e:
            logger.error(f"Failed to read metadata file: {e}")
            return {}
    
    def _write_metadata_atomic(self, metadata: Dict[str, Any]) -> bool:
        try:
            temp_file = self.metadata_file.with_suffix(".tmp")
            
            with open(temp_file, 'w') as f:
                json.dump(metadata, f, indent=2, default=str)
            
            temp_file.replace(self.metadata_file)
            logger.info(f"Metadata updated successfully: {self.metadata_file}")
            return True
            
        except Exception as e:
            logger.error(f"Failed to write metadata file: {e}")
            return False
    
    def generate_product_metadata(self, 
                                 product_id: str, 
                                 product_name: str,
                                 images: List[Dict[str, Any]]) -> bool:
        try:
            metadata = self._read_existing_metadata()
            
            product_entry = {
                "id": product_id,
                "name": product_name,
                "images": images,
                "updated_at": datetime.utcnow().isoformat()
            }
            
            metadata[product_id] = product_entry
            
            return self._write_metadata_atomic(metadata)
            
        except Exception as e:
            logger.error(f"Failed to generate product metadata: {e}")
            return False
    
    def update_product_images(self, 
                             product_id: str,
                             product_name: str,
                             image_data: Dict[str, Any],
                             operation: str = "add") -> bool:
        try:
            metadata = self._read_existing_metadata()
            
            if product_id not in metadata:
                metadata[product_id] = {
                    "id": product_id,
                    "name": product_name,
                    "images": [],
                    "created_at": datetime.utcnow().isoformat()
                }
            
            product_entry = metadata[product_id]
            product_entry["name"] = product_name
            product_entry["updated_at"] = datetime.utcnow().isoformat()
            
            if operation == "add":
                product_entry["images"].append(image_data)
            elif operation == "remove":
                product_entry["images"] = [
                    img for img in product_entry["images"] 
                    if img.get("id") != image_data.get("id")
                ]
            elif operation == "update_primary":
                for img in product_entry["images"]:
                    img["is_primary"] = (img.get("id") == image_data.get("id"))
            
            return self._write_metadata_atomic(metadata)
            
        except Exception as e:
            logger.error(f"Failed to update product images in metadata: {e}")
            return False
    
    def remove_product(self, product_id: str) -> bool:
        try:
            metadata = self._read_existing_metadata()
            
            if product_id in metadata:
                del metadata[product_id]
                return self._write_metadata_atomic(metadata)
            
            return True
            
        except Exception as e:
            logger.error(f"Failed to remove product from metadata: {e}")
            return False
    
    def get_product_metadata(self, product_id: str) -> Dict[str, Any]:
        try:
            metadata = self._read_existing_metadata()
            return metadata.get(product_id, {})
            
        except Exception as e:
            logger.error(f"Failed to get product metadata: {e}")
            return {}
    
    def get_all_metadata(self) -> Dict[str, Any]:
        try:
            return self._read_existing_metadata()
        except Exception as e:
            logger.error(f"Failed to get all metadata: {e}")
            return {}
    
    def validate_metadata_schema(self) -> bool:
        try:
            metadata = self._read_existing_metadata()
            
            required_product_fields = ["id", "name", "images", "updated_at"]
            required_image_fields = ["id", "url", "is_primary"]
            
            for product_id, product_data in metadata.items():
                for field in required_product_fields:
                    if field not in product_data:
                        logger.error(f"Missing field '{field}' in product {product_id}")
                        return False
                
                for image in product_data.get("images", []):
                    for field in required_image_fields:
                        if field not in image:
                            logger.error(f"Missing field '{field}' in image for product {product_id}")
                            return False
            
            return True
            
        except Exception as e:
            logger.error(f"Failed to validate metadata schema: {e}")
            return False

========================================
File: services\product_helpers.py
========================================

from fastapi.responses import JSONResponse

def create_problem_response(
    status_code: int,
    error_type: str,
    title: str,
    detail: str,
    instance: str
) -> JSONResponse:
    problem_details = {
        "type": f"https://example.com/errors/{error_type}",
        "title": title,
        "status": status_code,
        "detail": detail,
        "instance": instance
    }
    return JSONResponse(
        status_code=status_code,
        content=problem_details,
        media_type="application/problem+json"
    )

========================================
File: services\product_services.py
========================================

from .product_helpers import create_problem_response
from fastapi import Request
from fastapi.responses import JSONResponse
from database import pydantic_models
from repositories.product_repository import ProductRepository
from repositories.image_repository import ImageRepository  # NEW
from database.database_models import ProductDB
from datetime import datetime
from services.image_services import ImageService
class ProductService:
    def __init__(self, logger):
        self.logger = logger
        self.product_repository = ProductRepository()
        self.image_repository = ImageRepository()  # NEW

    async def create_product(
        self,
        request: Request,
        product_data: pydantic_models.ProductRequest
    ):
        self.logger.info(f"Product creation attempt: {product_data.name}")
        
        product_db = ProductDB(
            name=product_data.name,
            price=product_data.price,
            stock=product_data.stock,
            description=product_data.description
        )
        
        created_product = await self.product_repository.create_product(product_db)
        
        if not created_product:
            return create_problem_response(
                status_code=409,
                error_type="conflict",
                title="Conflict",
                detail="Product with this name already exists",
                instance=str(request.url)
            )
        
        product_response = pydantic_models.ProductResponse(
            id=created_product.id,
            name=created_product.name,
            price=created_product.price,
            stock=created_product.stock,
            description=created_product.description,
            images=[],  # NEW: Empty images array
            primary_image_id=None  # NEW: No primary image initially
        )
        
        self.logger.info(f"Product created successfully: {created_product.id}")
        
        response = JSONResponse(
            status_code=201,
            content=product_response.model_dump(),
            headers={"Location": f"/api/products/{created_product.id}"}
        )
        return response

    async def get_product(
        self,
        request: Request,
        product_id: str
    ):
        self.logger.info(f"Product retrieval attempt: {product_id}")
        
        product_db = await self.product_repository.get_product_by_id(product_id)
        
        if not product_db:
            return create_problem_response(
                status_code=404,
                error_type="not-found",
                title="Not Found",
                detail="Product not found",
                instance=str(request.url)
            )
        
        # NEW: Get product images
        images = []
        if product_db.image_ids:
            for image_id in product_db.image_ids:
                image = await self.image_repository.get_image_by_id(image_id)
                if image:
                    image_url = f"/static/img/products/{product_id}/{image.filename}"
                    images.append(pydantic_models.ProductImage(
                        id=image.id,
                        product_id=image.product_id,
                        filename=image.filename,
                        original_name=image.original_name,
                        mime_type=image.mime_type,
                        size=image.size,
                        width=image.width,
                        height=image.height,
                        is_primary=image.is_primary,
                        url=image_url,
                        uploaded_at=image.uploaded_at
                    ))
        
        product_response = pydantic_models.ProductResponse(
            id=product_db.id,
            name=product_db.name,
            price=product_db.price,
            stock=product_db.stock,
            description=product_db.description,
            images=images,  # NEW: Include images
            primary_image_id=product_db.primary_image_id  # NEW: Include primary image ID
        )
        
        self.logger.info(f"Product retrieved successfully: {product_id}")
        return product_response

    async def list_products(
        self,
        request: Request,
        query_params: pydantic_models.ProductQueryParams
    ):
        self.logger.info(f"Products listing attempt - Page: {query_params.page}, Size: {query_params.page_size}")
        
        skip = (query_params.page - 1) * query_params.page_size
        limit = query_params.page_size
        
        products_db = await self.product_repository.list_products(
            skip=skip,
            limit=limit,
            search_query=query_params.q
        )
        
        total = await self.product_repository.count_products(search_query=query_params.q)
        
        items = []
        for product in products_db:
            # NEW: Get images for each product
            images = []
            if product.image_ids:
                # Get first few images (for listing, maybe just primary or first image)
                for i, image_id in enumerate(product.image_ids[:3]):  # Limit to 3 images for listing
                    image = await self.image_repository.get_image_by_id(image_id)
                    if image:
                        image_url = f"/static/img/products/{product.id}/{image.filename}"
                        images.append(pydantic_models.ProductImage(
                            id=image.id,
                            product_id=image.product_id,
                            filename=image.filename,
                            original_name=image.original_name,
                            mime_type=image.mime_type,
                            size=image.size,
                            width=image.width,
                            height=image.height,
                            is_primary=image.is_primary,
                            url=image_url,
                            uploaded_at=image.uploaded_at
                        ))
            
            items.append(pydantic_models.ProductResponse(
                id=product.id,
                name=product.name,
                price=product.price,
                stock=product.stock,
                description=product.description,
                images=images,  # NEW: Include images
                primary_image_id=product.primary_image_id  # NEW: Include primary image ID
            ))
        
        product_list = pydantic_models.ProductList(
            items=items,
            total=total,
            page=query_params.page,
            page_size=query_params.page_size
        )
        
        self.logger.info(f"Products listed successfully - Found: {total}")
        return product_list

    async def update_product(
        self,
        request: Request,
        product_id: str,
        update_data: pydantic_models.ProductRequest
    ):
        self.logger.info(f"Product update attempt: {product_id}")
        
        update_dict = {
            "name": update_data.name,
            "price": update_data.price,
            "stock": update_data.stock,
            "description": update_data.description
        }
        
        updated_product_db = await self.product_repository.update_product(product_id, update_dict)
        
        if not updated_product_db:
            return create_problem_response(
                status_code=404,
                error_type="not-found",
                title="Not Found",
                detail="Product not found or name conflict",
                instance=str(request.url)
            )
        
        # NEW: Get product images for response
        images = []
        if updated_product_db.image_ids:
            for image_id in updated_product_db.image_ids:
                image = await self.image_repository.get_image_by_id(image_id)
                if image:
                    image_url = f"/static/img/products/{product_id}/{image.filename}"
                    images.append(pydantic_models.ProductImage(
                        id=image.id,
                        product_id=image.product_id,
                        filename=image.filename,
                        original_name=image.original_name,
                        mime_type=image.mime_type,
                        size=image.size,
                        width=image.width,
                        height=image.height,
                        is_primary=image.is_primary,
                        url=image_url,
                        uploaded_at=image.uploaded_at
                    ))
        
        updated_product = pydantic_models.ProductResponse(
            id=updated_product_db.id,
            name=updated_product_db.name,
            price=updated_product_db.price,
            stock=updated_product_db.stock,
            description=updated_product_db.description,
            images=images,  # NEW: Include images
            primary_image_id=updated_product_db.primary_image_id  # NEW: Include primary image ID
        )
        
        self.logger.info(f"Product updated successfully: {product_id}")
        return updated_product

    async def patch_product(
        self,
        request: Request,
        product_id: str,
        patch_data: pydantic_models.ProductPatch
    ):
        self.logger.info(f"Product patch attempt: {product_id}")
        
        patch_dict = patch_data.model_dump(exclude_unset=True)
        
        patched_product_db = await self.product_repository.update_product(product_id, patch_dict)
        
        if not patched_product_db:
            return create_problem_response(
                status_code=404,
                error_type="not-found",
                title="Not Found",
                detail="Product not found or name conflict",
                instance=str(request.url)
            )
        
        # NEW: Get product images for response
        images = []
        if patched_product_db.image_ids:
            for image_id in patched_product_db.image_ids:
                image = await self.image_repository.get_image_by_id(image_id)
                if image:
                    image_url = f"/static/img/products/{product_id}/{image.filename}"
                    images.append(pydantic_models.ProductImage(
                        id=image.id,
                        product_id=image.product_id,
                        filename=image.filename,
                        original_name=image.original_name,
                        mime_type=image.mime_type,
                        size=image.size,
                        width=image.width,
                        height=image.height,
                        is_primary=image.is_primary,
                        url=image_url,
                        uploaded_at=image.uploaded_at
                    ))
        
        patched_product = pydantic_models.ProductResponse(
            id=patched_product_db.id,
            name=patched_product_db.name,
            price=patched_product_db.price,
            stock=patched_product_db.stock,
            description=patched_product_db.description,
            images=images,  # NEW: Include images
            primary_image_id=patched_product_db.primary_image_id  # NEW: Include primary image ID
        )
        
        self.logger.info(f"Product patched successfully: {product_id}")
        return patched_product

    async def delete_product(
        self,
        request: Request,
        product_id: str
    ):
        self.logger.info(f"Product deletion attempt: {product_id}")
        
        # NEW: Get product info before deletion for metadata cleanup
        product = await self.product_repository.get_product_by_id(product_id)
        
        deleted = await self.product_repository.delete_product(product_id)
        
        if not deleted:
            return create_problem_response(
                status_code=404,
                error_type="not-found",
                title="Not Found",
                detail="Product not found",
                instance=str(request.url)
            )
        
        # NEW: Delete associated images from storage and metadata
        if product and product.image_ids:
            from services.image_services import ImageService
            image_service = ImageService()
            
            for image_id in product.image_ids:
                try:
                    await image_service.delete_product_image(product_id, image_id)
                except Exception as e:
                    self.logger.error(f"Failed to delete image {image_id} for product {product_id}: {e}")
        
        self.logger.info(f"Product deleted successfully: {product_id}")
        return None

    async def update_inventory(
        self,
        request: Request,
        product_id: str,
        inventory_data: pydantic_models.InventoryUpdate
    ):
        self.logger.info(f"Inventory update attempt: {product_id}")
        
        updated_product_db = await self.product_repository.update_inventory(
            product_id, 
            inventory_data.stock
        )
        
        if not updated_product_db:
            return create_problem_response(
                status_code=404,
                error_type="not-found",
                title="Not Found",
                detail="Product not found",
                instance=str(request.url)
            )
        
        response_data = pydantic_models.InventoryResponse(
            id=updated_product_db.id,
            stock=updated_product_db.stock
        )
        
        self.logger.info(f"Inventory updated successfully: {product_id} -> Stock: {inventory_data.stock}")
        return response_data

========================================
File: services\__init__.py
========================================



========================================
File: tests\test_image_contract.py
========================================

import pytest
import asyncio
from fastapi.testclient import TestClient
from fastapi import FastAPI, UploadFile
from unittest.mock import Mock, AsyncMock, patch
from io import BytesIO
import json

from services.image_services import ImageService
from database import pydantic_models
from routes.image_routes import router, get_image_service

app = FastAPI()
app.include_router(router)

@pytest.fixture
def mock_image_service():
    service = Mock(spec=ImageService)
    service.upload_product_image = AsyncMock()
    service.get_product_images = AsyncMock()
    service.delete_product_image = AsyncMock()
    service.set_primary_image = AsyncMock()
    return service

@pytest.fixture
def client(mock_image_service):
    app.dependency_overrides[get_image_service] = lambda: mock_image_service
    with TestClient(app) as test_client:
        yield test_client
    app.dependency_overrides.clear()

@pytest.fixture
def sample_image_response():
    return {
        "id": "img_123",
        "product_id": "prod_456",
        "filename": "prod_456_abc123.jpg",
        "original_name": "test.jpg",
        "mime_type": "image/jpeg",
        "size": 1024000,
        "width": 800,
        "height": 600,
        "is_primary": True,
        "url": "/static/img/products/prod_456/prod_456_abc123.jpg",
        "uploaded_at": "2023-10-01T12:00:00Z"
    }

@pytest.fixture
def mock_image_file():
    return ("test.jpg", BytesIO(b"fake image content"), "image/jpeg")

class TestImageRoutesContract:
    def test_upload_product_image_success(self, client, mock_image_service, sample_image_response):
        mock_image_service.upload_product_image.return_value = pydantic_models.ProductImage(**sample_image_response)
        
        files = {"file": ("test.jpg", b"fake image content", "image/jpeg")}
        data = {"is_primary": "true"}
        
        response = client.post(
            "/images/products/prod_456",
            files=files,
            data=data
        )
        
        assert response.status_code == 201
        assert response.json() == sample_image_response
        mock_image_service.upload_product_image.assert_called_once()

    def test_upload_product_image_missing_file(self, client):
        response = client.post(
            "/images/products/prod_456",
            data={"is_primary": "false"}
        )
        
        assert response.status_code == 422

    def test_list_product_images_success(self, client, mock_image_service, sample_image_response):
        mock_image = pydantic_models.ProductImage(**sample_image_response)
        mock_image_service.get_product_images.return_value = [mock_image]
        
        response = client.get("/images/products/prod_456")
        
        assert response.status_code == 200
        data = response.json()
        assert len(data["items"]) == 1
        assert data["items"][0] == sample_image_response
        assert data["total"] == 1
        mock_image_service.get_product_images.assert_called_once_with("prod_456")

    def test_get_product_image_success(self, client, mock_image_service, sample_image_response):
        mock_image = pydantic_models.ProductImage(**sample_image_response)
        mock_image_service.get_product_images.return_value = [mock_image]
        
        response = client.get("/images/products/prod_456/img_123")
        
        assert response.status_code == 200
        assert response.json() == sample_image_response
        mock_image_service.get_product_images.assert_called_once_with("prod_456")

    def test_get_product_image_not_found(self, client, mock_image_service):
        mock_image_service.get_product_images.return_value = []
        
        response = client.get("/images/products/prod_456/non_existent")
        
        assert response.status_code == 404
        assert "Not Found" in response.json()["title"]

    def test_delete_product_image_success(self, client, mock_image_service):
        mock_image_service.delete_product_image.return_value = True
        
        response = client.delete("/images/products/prod_456/img_123")
        
        assert response.status_code == 204
        mock_image_service.delete_product_image.assert_called_once_with("prod_456", "img_123")

    def test_delete_product_image_not_found(self, client, mock_image_service):
        mock_image_service.delete_product_image.return_value = False
        
        response = client.delete("/images/products/prod_456/non_existent")
        
        assert response.status_code == 404
        assert "Not Found" in response.json()["title"]

    def test_set_primary_image_success(self, client, mock_image_service, sample_image_response):
        mock_image = pydantic_models.ProductImage(**sample_image_response)
        mock_image_service.set_primary_image.return_value = mock_image
        
        response = client.patch("/images/products/prod_456/img_123/primary")
        
        assert response.status_code == 200
        assert response.json() == sample_image_response
        mock_image_service.set_primary_image.assert_called_once_with("prod_456", "img_123")

    def test_set_primary_image_not_found(self, client, mock_image_service):
        mock_image_service.set_primary_image.side_effect = Exception("Image not found")
        
        response = client.patch("/images/products/prod_456/non_existent/primary")
        
        assert response.status_code == 500

    def test_invalid_product_id_format(self, client):
        response = client.get("/images/products/invalid@id")
        
        assert response.status_code == 200

    def test_invalid_image_id_format(self, client, mock_image_service):
        mock_image_service.get_product_images.return_value = []
        
        response = client.get("/images/products/prod_456/invalid@id")
        
        assert response.status_code == 404

    def test_method_not_allowed(self, client):
        response = client.post("/images/products/prod_456/img_123")
        
        assert response.status_code == 405

    def test_route_not_found(self, client):
        response = client.get("/images/nonexistent/route")
        
        assert response.status_code == 404

class TestImageRoutesErrorScenarios:
    def test_upload_file_too_large(self, client, mock_image_service):
        mock_image_service.upload_product_image.side_effect = Exception("File too large")
        
        files = {"file": ("large.jpg", b"x" * 10000000, "image/jpeg")}
        
        response = client.post("/images/products/prod_456", files=files)
        
        assert response.status_code == 500

    def test_upload_invalid_file_type(self, client, mock_image_service):
        mock_image_service.upload_product_image.side_effect = Exception("Invalid file type")
        
        files = {"file": ("test.pdf", b"fake pdf content", "application/pdf")}
        
        response = client.post("/images/products/prod_456", files=files)
        
        assert response.status_code == 500

    def test_product_not_found_upload(self, client, mock_image_service):
        mock_image_service.upload_product_image.side_effect = Exception("Product not found")
        
        files = {"file": ("test.jpg", b"fake content", "image/jpeg")}
        
        response = client.post("/images/products/non_existent", files=files)
        
        assert response.status_code == 500

    def test_service_raises_exception(self, client, mock_image_service):
        mock_image_service.get_product_images.side_effect = Exception("Database error")
        
        response = client.get("/images/products/prod_456")
        
        assert response.status_code == 500

class TestImageRoutesContentTypes:
    def test_json_content_type(self, client, mock_image_service, sample_image_response):
        mock_image = pydantic_models.ProductImage(**sample_image_response)
        mock_image_service.get_product_images.return_value = [mock_image]
        
        response = client.get("/images/products/prod_456")
        
        assert response.headers["content-type"] == "application/json"

    def test_upload_multipart_form_data(self, client, mock_image_service, sample_image_response):
        mock_image = pydantic_models.ProductImage(**sample_image_response)
        mock_image_service.upload_product_image.return_value = mock_image
        
        files = {"file": ("test.jpg", b"fake image content", "image/jpeg")}
        
        response = client.post(
            "/images/products/prod_456",
            files=files
        )
        
        assert response.status_code == 201
        assert response.json() == sample_image_response

    def test_wrong_content_type_upload(self, client):
        response = client.post(
            "/images/products/prod_456",
            json={"file": "base64encoded"},
            headers={"Content-Type": "application/json"}
        )
        
        assert response.status_code == 422

def test_batch_upload_images_success(client, mock_image_service):
    """Test successful batch upload with multiple files."""
    files = [
        ("files", ("image1.jpg", b"fake image data 1", "image/jpeg")),
        ("files", ("image2.png", b"fake image data 2", "image/png")),
    ]
    
    mock_response = {
        "success": [
            {
                "id": "img1", "filename": "test1.jpg", "url": "/static/img/test1.jpg",
                "product_id": "prod123", "original_name": "image1.jpg",
                "mime_type": "image/jpeg", "size": 100, "width": 100, "height": 100,
                "is_primary": True, "uploaded_at": "2023-01-01T00:00:00"
            },
            {
                "id": "img2", "filename": "test2.png", "url": "/static/img/test2.png",
                "product_id": "prod123", "original_name": "image2.png",
                "mime_type": "image/png", "size": 200, "width": 200, "height": 200,
                "is_primary": False, "uploaded_at": "2023-01-01T00:00:00"
            }
        ],
        "failed": [],
        "total": 2,
        "successful_count": 2
    }
    
    mock_image_service.upload_product_images_batch = AsyncMock(return_value=mock_response)
    
    response = client.post(
        "/images/products/prod123/batch",
        files=files,
        data={"make_primary_first": "true"}
    )
    
    assert response.status_code == 207
    data = response.json()
    assert data["total"] == 2
    assert data["successful_count"] == 2
    assert len(data["success"]) == 2
    assert len(data["failed"]) == 0

def test_batch_upload_partial_success(client, mock_image_service):
    """Test batch upload with partial success (some files fail)."""
    files = [
        ("files", ("image1.jpg", b"fake data 1", "image/jpeg")),
        ("files", ("image2.gif", b"fake data 2", "image/gif")),  
    ]
    
    mock_response = {
        "success": [
            {
                "id": "img1", "filename": "test1.jpg", "url": "/static/img/test1.jpg",
                "product_id": "prod123", "original_name": "image1.jpg",
                "mime_type": "image/jpeg", "size": 100, "width": 100, "height": 100,
                "is_primary": True, "uploaded_at": "2023-01-01T00:00:00"
            }
        ],
        "failed": [
            {"filename": "image2.gif", "error": "Invalid image format", "status_code": 415}
        ],
        "total": 2,
        "successful_count": 1
    }
    
    mock_image_service.upload_product_images_batch = AsyncMock(return_value=mock_response)
    
    response = client.post("/images/products/prod123/batch", files=files)
    assert response.status_code == 207
    data = response.json()
    assert data["successful_count"] == 1
    assert len(data["failed"]) == 1
    assert data["failed"][0]["filename"] == "image2.gif"

def test_batch_upload_no_files(client):
    """Test batch upload with no files."""
    response = client.post("/images/products/prod123/batch", files=[])
    assert response.status_code == 422  
    
def test_batch_upload_product_not_found(client, mock_image_service):
    """Test batch upload for non-existent product."""
    from fastapi import HTTPException
    files = [("files", ("image1.jpg", b"fake data", "image/jpeg"))]
    
    mock_image_service.upload_product_images_batch = AsyncMock(
        side_effect=HTTPException(status_code=404, detail="Product not found")
    )
    
    response = client.post("/images/products/nonexistent/batch", files=files)
    assert response.status_code == 404

if __name__ == "__main__":
    import asyncio
    
    async def run_tests():
        print("Running image routes tests...")
        
        mock_service = Mock(spec=ImageService)
        
        app.dependency_overrides[get_image_service] = lambda: mock_service
        
        with TestClient(app) as test_client:
            response = test_client.get("/images/products/test_id")
            print(f"GET /images/products/test_id: {response.status_code}")
            
            response = test_client.post(
                "/images/products/test_id",
                files={"file": ("test.jpg", b"fake", "image/jpeg")}
            )
            print(f"POST /images/products/test_id: {response.status_code}")
        
        app.dependency_overrides.clear()
        print("Image routes tests completed!")
    
    asyncio.run(run_tests())

========================================
File: tests\test_image_repository.py
========================================

import pytest
import asyncio
import os
from motor.motor_asyncio import AsyncIOMotorClient
from database.connection import MongoDBConnection
from repositories.image_repository import ImageRepository
from database.database_models import ImageDB

from unittest.mock import AsyncMock, patch, MagicMock
import asyncio

TEST_DB_NAME = "test_product_db"
TEST_CONNECTION_STRING = os.getenv("TEST_MONGODB_URI", "mongodb://localhost:27017/")

@pytest.fixture(scope="function")
async def test_db_setup():
    connection = MongoDBConnection()
    await connection.connect(TEST_CONNECTION_STRING, TEST_DB_NAME)
    collection = connection.get_images_collection()
    
    await collection.delete_many({})
    
    test_images = [
        {
            "_id": "img_1",
            "product_id": "prod_1",
            "filename": "prod_1_img1.jpg",
            "original_name": "laptop_front.jpg",
            "mime_type": "image/jpeg",
            "size": 1024000,
            "width": 800,
            "height": 600,
            "is_primary": True,
            "uploaded_at": "2023-01-01T10:00:00"
        },
        {
            "_id": "img_2",
            "product_id": "prod_1",
            "filename": "prod_1_img2.jpg",
            "original_name": "laptop_back.jpg",
            "mime_type": "image/jpeg",
            "size": 980000,
            "width": 800,
            "height": 600,
            "is_primary": False,
            "uploaded_at": "2023-01-01T10:05:00"
        },
        {
            "_id": "img_3",
            "product_id": "prod_2",
            "filename": "prod_2_img1.jpg",
            "original_name": "mouse.jpg",
            "mime_type": "image/jpeg",
            "size": 512000,
            "width": 600,
            "height": 400,
            "is_primary": True,
            "uploaded_at": "2023-01-02T09:00:00"
        }
    ]
    
    await collection.insert_many(test_images)
    
    repository = ImageRepository(collection=collection)
    
    yield repository, connection, collection
    
    await collection.delete_many({})
    await connection.close()

@pytest.mark.asyncio
async def test_create_image_success(test_db_setup):
    repository, connection, collection = test_db_setup
    
    new_image = ImageDB(
        id="img_4",
        product_id="prod_3",
        filename="prod_3_img1.jpg",
        original_name="keyboard.jpg",
        mime_type="image/jpeg",
        size=750000,
        width=700,
        height=500,
        is_primary=True
    )
    
    result = await repository.create_image(new_image)
    
    assert result is not None
    assert result.filename == "prod_3_img1.jpg"
    assert result.product_id == "prod_3"
    
    fetched = await repository.get_image_by_id("img_4")
    assert fetched.filename == "prod_3_img1.jpg"

@pytest.mark.asyncio
async def test_get_image_by_id_success(test_db_setup):
    repository, connection, collection = test_db_setup
    
    result = await repository.get_image_by_id("img_1")
    
    assert result is not None
    assert result.id == "img_1"
    assert result.product_id == "prod_1"
    assert result.is_primary == True

@pytest.mark.asyncio
async def test_get_image_by_id_not_found(test_db_setup):
    repository, connection, collection = test_db_setup
    
    result = await repository.get_image_by_id("non_existent")
    assert result is None

@pytest.mark.asyncio
async def test_get_images_by_product_id(test_db_setup):
    repository, connection, collection = test_db_setup
    
    images = await repository.get_images_by_product_id("prod_1")
    
    assert len(images) == 2
    image_ids = [img.id for img in images]
    assert "img_1" in image_ids
    assert "img_2" in image_ids

@pytest.mark.asyncio
async def test_get_images_by_product_id_empty(test_db_setup):
    repository, connection, collection = test_db_setup
    
    images = await repository.get_images_by_product_id("prod_999")
    assert len(images) == 0

@pytest.mark.asyncio
async def test_get_primary_image_by_product_id_success(test_db_setup):
    repository, connection, collection = test_db_setup
    
    result = await repository.get_primary_image_by_product_id("prod_1")
    
    assert result is not None
    assert result.id == "img_1"
    assert result.is_primary == True

@pytest.mark.asyncio
async def test_get_primary_image_by_product_id_not_found(test_db_setup):
    repository, connection, collection = test_db_setup
    
    result = await repository.get_primary_image_by_product_id("prod_999")
    assert result is None

@pytest.mark.asyncio
async def test_update_image_success(test_db_setup):
    repository, connection, collection = test_db_setup
    
    update_data = {
        "original_name": "updated_laptop.jpg",
        "is_primary": False
    }
    
    result = await repository.update_image("img_1", update_data)
    
    assert result is not None
    assert result.original_name == "updated_laptop.jpg"
    assert result.is_primary == False

@pytest.mark.asyncio
async def test_update_image_not_found(test_db_setup):
    repository, connection, collection = test_db_setup
    
    result = await repository.update_image("non_existent", {"original_name": "test.jpg"})
    assert result is None

@pytest.mark.asyncio
async def test_delete_image_success(test_db_setup):
    repository, connection, collection = test_db_setup
    
    result = await repository.delete_image("img_1")
    assert result is True
    
    fetched = await repository.get_image_by_id("img_1")
    assert fetched is None

@pytest.mark.asyncio
async def test_delete_image_not_found(test_db_setup):
    repository, connection, collection = test_db_setup
    
    result = await repository.delete_image("non_existent")
    assert result is False

@pytest.mark.asyncio
async def test_set_primary_image_success(test_db_setup):
    repository, connection, collection = test_db_setup
    
    result = await repository.set_primary_image("prod_1", "img_2")
    
    assert result is True
    
    primary_image = await repository.get_primary_image_by_product_id("prod_1")
    assert primary_image.id == "img_2"
    
    old_primary = await repository.get_image_by_id("img_1")
    assert old_primary.is_primary == False

@pytest.mark.asyncio
async def test_set_primary_image_not_found(test_db_setup):
    repository, connection, collection = test_db_setup
    
    result = await repository.set_primary_image("prod_999", "img_999")
    assert result is False

@pytest.mark.asyncio
async def test_count_images_by_product_id(test_db_setup):
    repository, connection, collection = test_db_setup
    
    count = await repository.count_images_by_product_id("prod_1")
    assert count == 2
    
    count_empty = await repository.count_images_by_product_id("prod_999")
    assert count_empty == 0

@pytest.mark.asyncio
async def test_get_recent_images(test_db_setup):
    repository, connection, collection = test_db_setup
    
    recent_images = await repository.get_recent_images(limit=2)
    
    assert len(recent_images) == 2
    assert recent_images[0].id == "img_3"
    assert recent_images[1].id == "img_2"

@pytest.mark.asyncio
async def test_init_without_collection():
    repo = ImageRepository()
    assert repo.collection is None

@pytest.mark.asyncio
async def test__get_collection_lazy_loading():
    repo = ImageRepository()
    mock_collection = AsyncMock()
    with patch('repositories.image_repository.get_images_collection', AsyncMock(return_value=mock_collection)):
        result = await repo._get_collection()
        assert result == mock_collection
        assert repo.collection == mock_collection

@pytest.mark.asyncio
async def test_create_image_insert_failure(test_db_setup):
    repository, connection, collection = test_db_setup
    mock_collection = AsyncMock()
    mock_collection.insert_one = AsyncMock(return_value=MagicMock(inserted_id=None))
    repository.collection = mock_collection
    
    new_image = ImageDB(
        id="img_fail",
        product_id="prod_fail",
        filename="fail.jpg",
        original_name="fail.jpg",
        mime_type="image/jpeg",
        size=1000,
        width=100,
        height=100,
        is_primary=True
    )
    
    result = await repository.create_image(new_image)
    assert result is None

@pytest.mark.asyncio
async def test_get_image_by_id_malformed_data(test_db_setup):
    repository, connection, collection = test_db_setup
    bad_data = {"_id": "bad_img", "invalid": "data"}
    await collection.insert_one(bad_data)
    
    with pytest.raises(Exception):
        await repository.get_image_by_id("bad_img")

@pytest.mark.asyncio
async def test_update_image_no_changes(test_db_setup):
    repository, connection, collection = test_db_setup
    
    original = await repository.get_image_by_id("img_1")
    update_data = {"original_name": original.original_name}
    
    result = await repository.update_image("img_1", update_data)
    assert result is not None
    assert result.original_name == original.original_name

@pytest.mark.asyncio
async def test_set_primary_image_already_primary(test_db_setup):
    repository, connection, collection = test_db_setup
    
    result = await repository.set_primary_image("prod_1", "img_1")
    assert result is True

@pytest.mark.asyncio
async def test_set_primary_image_wrong_product(test_db_setup):
    repository, connection, collection = test_db_setup
    
    result = await repository.set_primary_image("prod_2", "img_1")
    assert result is False

@pytest.mark.asyncio
async def test_get_recent_images_limit_zero(test_db_setup):
    repository, connection, collection = test_db_setup
    
    images = await repository.get_recent_images(limit=0)
    assert len(images) == 0

@pytest.mark.asyncio
async def test_get_recent_images_large_limit(test_db_setup):
    repository, connection, collection = test_db_setup
    
    images = await repository.get_recent_images(limit=1000)
    assert len(images) == 3

@pytest.mark.asyncio
async def test_get_recent_images_negative_limit(test_db_setup):
    repository, connection, collection = test_db_setup

    with pytest.raises(ValueError, match="non-negative"):
        await repository.get_recent_images(limit=-1)

@pytest.mark.asyncio
async def test_count_images_by_product_id_large_collection(test_db_setup):
    repository, connection, collection = test_db_setup
    
    for i in range(10):
        image = ImageDB(
            id=f"bulk_{i}",
            product_id="prod_bulk",
            filename=f"bulk_{i}.jpg",
            original_name=f"bulk_{i}.jpg",
            mime_type="image/jpeg",
            size=1000,
            width=100,
            height=100,
            is_primary=False
        )
        await repository.create_image(image)
    
    count = await repository.count_images_by_product_id("prod_bulk")
    assert count == 10

@pytest.mark.asyncio
async def test_concurrent_set_primary_image(test_db_setup):
    repository, connection, collection = test_db_setup
    
    async def set_primary_task(image_id):
        return await repository.set_primary_image("prod_1", image_id)
    
    tasks = [set_primary_task("img_1"), set_primary_task("img_2")]
    results = await asyncio.gather(*tasks, return_exceptions=True)
    
    primary_count = await collection.count_documents({"product_id": "prod_1", "is_primary": True})
    assert primary_count == 1

@pytest.mark.asyncio
async def test_update_image_with_empty_data(test_db_setup):
    repository, connection, collection = test_db_setup
    
    result = await repository.update_image("img_1", {})
    assert result is not None

@pytest.mark.asyncio
async def test_delete_image_already_deleted(test_db_setup):
    repository, connection, collection = test_db_setup
    
    await repository.delete_image("img_1")
    result = await repository.delete_image("img_1")
    assert result is False

@pytest.mark.asyncio
async def test_get_primary_image_no_primary(test_db_setup):
    repository, connection, collection = test_db_setup
    
    await collection.update_many({}, {"$set": {"is_primary": False}})
    
    result = await repository.get_primary_image_by_product_id("prod_1")
    assert result is None

@pytest.mark.asyncio
async def test_create_image_duplicate_id(test_db_setup):
    repository, connection, collection = test_db_setup
    
    duplicate_image = ImageDB(
        id="img_1",
        product_id="prod_duplicate",
        filename="duplicate.jpg",
        original_name="duplicate.jpg",
        mime_type="image/jpeg",
        size=1000,
        width=100,
        height=100,
        is_primary=True
    )
    
    with pytest.raises(Exception):
        await repository.create_image(duplicate_image)

@pytest.mark.asyncio
async def test_decorator_validation_failure(test_db_setup):
    repository, connection, collection = test_db_setup
    
    # Test get_image_by_id with empty string
    with pytest.raises(ValueError, match="Invalid image ID"):
        await repository.get_image_by_id("")
    
    # Test get_image_by_id with None
    with pytest.raises(ValueError, match="Invalid image ID"):
        await repository.get_image_by_id(None)
    
    # Test get_image_by_id with non-string
    with pytest.raises(ValueError, match="Invalid image ID"):
        await repository.get_image_by_id(123)
    
    # Test get_images_by_product_id with empty string  
    with pytest.raises(ValueError, match="Invalid product ID"):
        await repository.get_images_by_product_id("")
    
    # Test set_primary_image with empty product_id
    with pytest.raises(ValueError, match="Invalid product ID"):
        await repository.set_primary_image("", "img_1")
    
    # Test set_primary_image with empty image_id
    with pytest.raises(ValueError, match="Invalid image ID"):
        await repository.set_primary_image("prod_1", "")
    
    # Test set_primary_image with None values
    with pytest.raises(ValueError, match="Invalid product ID"):
        await repository.set_primary_image(None, "img_1")
    
    with pytest.raises(ValueError, match="Invalid image ID"):
        await repository.set_primary_image("prod_1", None)
    
    # Test get_primary_image_by_product_id with empty string
    with pytest.raises(ValueError, match="Invalid product ID"):
        await repository.get_primary_image_by_product_id("")
    
    # Test count_images_by_product_id with empty string
    with pytest.raises(ValueError, match="Invalid product ID"):
        await repository.count_images_by_product_id("")


@pytest.mark.asyncio
async def test_decorator_error_handling():
    mock_collection = AsyncMock()
    mock_collection.find_one = AsyncMock(side_effect=Exception("DB Error"))
    repo = ImageRepository(collection=mock_collection)
    
    with pytest.raises(Exception):
        await repo.get_image_by_id("valid_id")

@pytest.mark.asyncio
async def test_empty_string_fields(test_db_setup):
    repository, connection, collection = test_db_setup
    
    empty_image = ImageDB(
        id="img_empty",
        product_id="",
        filename="",
        original_name="",
        mime_type="",
        size=0,
        width=0,
        height=0,
        is_primary=False
    )
    
    result = await repository.create_image(empty_image)
    assert result is not None

@pytest.mark.asyncio
async def test_set_primary_image_twice_different_images(test_db_setup):
    repository, connection, collection = test_db_setup
    
    result1 = await repository.set_primary_image("prod_1", "img_2")
    assert result1 is True
    
    result2 = await repository.set_primary_image("prod_1", "img_1")
    assert result2 is True
    
    primary = await repository.get_primary_image_by_product_id("prod_1")
    assert primary.id == "img_1"

if __name__ == "__main__":
    import asyncio
    
    async def run_tests():
        connection = MongoDBConnection()
        await connection.connect(TEST_CONNECTION_STRING, TEST_DB_NAME)
        collection = connection.get_images_collection()
        await collection.delete_many({})
        
        repo = ImageRepository(collection=collection)
        
        test_image = ImageDB(
            id="test_img_1",
            product_id="test_prod_1",
            filename="test_image.jpg",
            original_name="test.jpg",
            mime_type="image/jpeg",
            size=1000000,
            width=800,
            height=600,
            is_primary=True
        )
        
        result = await repo.create_image(test_image)
        print(f"Create image: {'SUCCESS' if result else 'FAILED'}")
        
        fetched = await repo.get_image_by_id("test_img_1")
        print(f"Get image: {'SUCCESS' if fetched else 'FAILED'}")
        
        await collection.delete_many({})
        await connection.close()
    
    asyncio.run(run_tests())

========================================
File: tests\test_image_service.py
========================================

import pytest
import asyncio
import os
from unittest.mock import Mock, AsyncMock, patch, MagicMock
from fastapi import UploadFile, HTTPException
from pathlib import Path
import io

from services.image_services import ImageService
from repositories.image_repository import ImageRepository
from repositories.product_repository import ProductRepository
from database.database_models import ProductDB, ImageDB
from database import pydantic_models


@pytest.fixture
def mock_image_repository():
    repo = Mock(spec=ImageRepository)
    repo.create_image = AsyncMock()
    repo.get_image_by_id = AsyncMock()
    repo.get_images_by_product_id = AsyncMock()
    repo.set_primary_image = AsyncMock()
    repo.delete_image = AsyncMock()
    return repo


@pytest.fixture
def mock_product_repository():
    repo = Mock(spec=ProductRepository)
    repo.get_product_by_id = AsyncMock()
    repo.add_image_to_product = AsyncMock()
    repo.remove_image_from_product = AsyncMock()
    repo.set_primary_image = AsyncMock()
    return repo


@pytest.fixture
def image_service(mock_image_repository, mock_product_repository):
    """Fixture for ImageService with mocked dependencies"""
    with patch('services.image_services.magic.Magic') as mock_magic:
        mock_magic_instance = Mock()
        mock_magic_instance.from_buffer.return_value = "image/jpeg"
        mock_magic.return_value = mock_magic_instance
        
        service = ImageService(
            image_repository=mock_image_repository,
            product_repository=mock_product_repository
        )
        yield service


@pytest.fixture
def sample_jpeg_content():
    return b'\xff\xd8\xff\xe0\x00\x10JFIF\x00\x01\x01\x00\x00\x01' + b'a' * 1000


@pytest.fixture
def mock_upload_file(sample_jpeg_content):
    file = Mock(spec=UploadFile)
    file.filename = "test.jpg"
    file.read = AsyncMock(return_value=sample_jpeg_content)
    return file


@pytest.fixture
def mock_product():
    return ProductDB(
        id="prod_123",
        name="Test Product",
        price=99.99,
        stock=10,
        description="Test Description",
        tags=["electronics"],
        image_ids=[],
        primary_image_id=None
    )


@pytest.fixture
def mock_image():
    return ImageDB(
        id="img_456",
        product_id="prod_123",
        filename="prod_123_abc123.jpg",
        original_name="test.jpg",
        mime_type="image/jpeg",
        size=1024000,
        width=800,
        height=600,
        is_primary=True
    )


@pytest.mark.asyncio
async def test_upload_product_image_success(image_service, mock_product_repository, mock_image_repository, mock_upload_file, mock_product, mock_image):
    mock_product_repository.get_product_by_id.return_value = mock_product
    mock_image_repository.create_image.return_value = mock_image
    mock_image_repository.set_primary_image.return_value = True
    
    mock_img = Mock()
    mock_img.size = (800, 600)
    
    with patch('PIL.Image.open') as mock_open:
        mock_open.return_value.__enter__.return_value = mock_img
        
        with patch('builtins.open'):
            with patch('os.rename'):
                with patch.object(Path, 'mkdir'):
                    result = await image_service.upload_product_image(
                        "prod_123", mock_upload_file, is_primary=True
                    )
    
    assert result is not None
    assert result.id == "img_456"
    assert result.product_id == "prod_123"
    assert result.is_primary == True
    
    mock_product_repository.get_product_by_id.assert_called_once_with("prod_123")
    mock_product_repository.add_image_to_product.assert_called_once_with("prod_123", "img_456")
    mock_product_repository.set_primary_image.assert_called_once_with("prod_123", "img_456")
    mock_image_repository.set_primary_image.assert_called_once_with("prod_123", "img_456")
    
    
    mock_product_repository.get_product_by_id.assert_called_once_with("prod_123")
    mock_product_repository.add_image_to_product.assert_called_once_with("prod_123", "img_456")
    mock_product_repository.set_primary_image.assert_called_once_with("prod_123", "img_456")
    mock_image_repository.set_primary_image.assert_called_once_with("prod_123", "img_456")


@pytest.mark.asyncio
async def test_upload_product_image_product_not_found(image_service, mock_product_repository, mock_upload_file):
    """Test image upload when product doesn't exist"""
    mock_product_repository.get_product_by_id.return_value = None
    
    with pytest.raises(HTTPException) as exc_info:
        await image_service.upload_product_image("prod_999", mock_upload_file)
    
    assert exc_info.value.status_code == 404
    assert "Product not found" in str(exc_info.value.detail)


@pytest.mark.asyncio
async def test_upload_product_image_file_too_large(image_service, mock_product_repository, mock_product, mock_upload_file):
    """Test image upload with file exceeding size limit"""
    mock_product_repository.get_product_by_id.return_value = mock_product
    
    large_content = b'a' * (6 * 1024 * 1024)
    mock_upload_file.read.return_value = large_content
    
    with pytest.raises(HTTPException) as exc_info:
        await image_service.upload_product_image("prod_123", mock_upload_file)
    
    assert exc_info.value.status_code == 413
    assert "File size exceeds" in str(exc_info.value.detail)


@pytest.mark.asyncio
async def test_upload_product_image_invalid_format(image_service, mock_product_repository, mock_product, mock_upload_file):
    """Test image upload with non-image file"""
    mock_product_repository.get_product_by_id.return_value = mock_product
    
    with patch('services.image_services.magic.Magic') as mock_magic:
        mock_magic_instance = Mock()
        mock_magic_instance.from_buffer.return_value = "application/pdf"
        mock_magic.return_value = mock_magic_instance
        
        with pytest.raises(HTTPException) as exc_info:
            await image_service.upload_product_image("prod_123", mock_upload_file)
    
    assert exc_info.value.status_code == 415
    assert "Invalid image format" in str(exc_info.value.detail)


@pytest.mark.asyncio
async def test_get_product_images_success(image_service, mock_product_repository, mock_image_repository, mock_product, mock_image):
    """Test retrieving product images successfully"""
    mock_product_repository.get_product_by_id.return_value = mock_product
    mock_image_repository.get_images_by_product_id.return_value = [mock_image]
    
    results = await image_service.get_product_images("prod_123")
    
    assert len(results) == 1
    assert results[0].id == "img_456"
    assert results[0].url == "/static/img/products/prod_123/prod_123_abc123.jpg"
    
    mock_product_repository.get_product_by_id.assert_called_once_with("prod_123")
    mock_image_repository.get_images_by_product_id.assert_called_once_with("prod_123")


@pytest.mark.asyncio
async def test_get_product_images_product_not_found(image_service, mock_product_repository):
    """Test retrieving images for non-existent product"""
    mock_product_repository.get_product_by_id.return_value = None
    
    with pytest.raises(HTTPException) as exc_info:
        await image_service.get_product_images("prod_999")
    
    assert exc_info.value.status_code == 404


@pytest.mark.asyncio
async def test_delete_product_image_success(image_service, mock_product_repository, mock_image_repository, mock_product, mock_image):
    """Test successful image deletion"""
    mock_product_repository.get_product_by_id.return_value = mock_product
    mock_image_repository.get_image_by_id.return_value = mock_image
    mock_image_repository.delete_image.return_value = True
    
    with patch.object(Path, 'exists', return_value=True):
        with patch.object(Path, 'unlink'):
            result = await image_service.delete_product_image("prod_123", "img_456")
    
    assert result is True
    mock_product_repository.remove_image_from_product.assert_called_once_with("prod_123", "img_456")


@pytest.mark.asyncio
async def test_delete_product_image_product_not_found(image_service, mock_product_repository):
    """Test image deletion for non-existent product"""
    mock_product_repository.get_product_by_id.return_value = None
    
    with pytest.raises(HTTPException) as exc_info:
        await image_service.delete_product_image("prod_999", "img_456")
    
    assert exc_info.value.status_code == 404


@pytest.mark.asyncio
async def test_delete_product_image_image_not_found(image_service, mock_product_repository, mock_image_repository, mock_product):
    """Test deletion of non-existent image"""
    mock_product_repository.get_product_by_id.return_value = mock_product
    mock_image_repository.get_image_by_id.return_value = None
    
    with pytest.raises(HTTPException) as exc_info:
        await image_service.delete_product_image("prod_123", "img_999")
    
    assert exc_info.value.status_code == 404


@pytest.mark.asyncio
async def test_delete_product_image_wrong_product(image_service, mock_product_repository, mock_image_repository, mock_product):
    """Test deletion of image belonging to different product"""
    mock_product_repository.get_product_by_id.return_value = mock_product
    
    wrong_product_image = ImageDB(
        id="img_456",
        product_id="prod_999",
        filename="wrong.jpg",
        original_name="wrong.jpg",
        mime_type="image/jpeg",
        size=1024000,
        width=800,
        height=600,
        is_primary=False
    )
    mock_image_repository.get_image_by_id.return_value = wrong_product_image
    
    with pytest.raises(HTTPException) as exc_info:
        await image_service.delete_product_image("prod_123", "img_456")
    
    assert exc_info.value.status_code == 404


@pytest.mark.asyncio
async def test_set_primary_image_success(image_service, mock_product_repository, mock_image_repository, mock_product, mock_image):
    """Test successful setting of primary image"""
    updated_product = ProductDB(
        id="prod_123",
        name="Test Product",
        price=99.99,
        stock=10,
        description="Test Description",
        tags=["electronics"],
        image_ids=["img_456", "img_789"],
        primary_image_id=None
    )
    
    mock_product_repository.get_product_by_id.return_value = updated_product
    mock_image_repository.set_primary_image.return_value = True
    mock_image_repository.get_image_by_id.return_value = mock_image
    
    result = await image_service.set_primary_image("prod_123", "img_456")
    
    assert result is not None
    assert result.id == "img_456"
    assert result.is_primary is True
    
    mock_product_repository.set_primary_image.assert_called_once_with("prod_123", "img_456")
    mock_image_repository.set_primary_image.assert_called_once_with("prod_123", "img_456")


@pytest.mark.asyncio
async def test_set_primary_image_product_not_found(image_service, mock_product_repository):
    """Test setting primary image for non-existent product"""
    mock_product_repository.get_product_by_id.return_value = None
    
    with pytest.raises(HTTPException) as exc_info:
        await image_service.set_primary_image("prod_999", "img_456")
    
    assert exc_info.value.status_code == 404


@pytest.mark.asyncio
async def test_set_primary_image_image_not_in_product(image_service, mock_product_repository, mock_product):
    """Test setting non-product image as primary"""
    mock_product_repository.get_product_by_id.return_value = mock_product
    
    with pytest.raises(HTTPException) as exc_info:
        await image_service.set_primary_image("prod_123", "img_999")
    
    assert exc_info.value.status_code == 400
    assert "Image does not belong" in str(exc_info.value.detail)


@pytest.mark.asyncio
async def test_set_primary_image_failed(image_service, mock_product_repository, mock_image_repository, mock_product):
    """Test failed primary image setting"""
    updated_product = ProductDB(
        id="prod_123",
        name="Test Product",
        price=99.99,
        stock=10,
        description="Test Description",
        tags=["electronics"],
        image_ids=["img_456"],
        primary_image_id=None
    )
    
    mock_product_repository.get_product_by_id.return_value = updated_product
    mock_image_repository.set_primary_image.return_value = False
    
    with pytest.raises(HTTPException) as exc_info:
        await image_service.set_primary_image("prod_123", "img_456")
    
    assert exc_info.value.status_code == 400
    assert "Failed to set primary image" in str(exc_info.value.detail)


@pytest.mark.asyncio
async def test_validate_file_path_security(image_service):
    """Test file path validation for security"""
    image_service.base_storage_path = Path("/static/img")
    
    valid_path = Path("/static/img/products/prod_123/test.jpg")
    assert image_service._validate_file_path(valid_path) is True
    
    traversal_path = Path("/static/img/products/prod_123/../other/test.jpg")
    assert image_service._validate_file_path(traversal_path) is False
    
    absolute_path = Path("C:\\windows\\system32\\file.jpg")
    assert image_service._validate_file_path(absolute_path) is False


def test_generate_server_filename(image_service):
    """Test server filename generation"""
    product_id = "prod_123"
    mime_type = "image/jpeg"
    
    filename = image_service._generate_server_filename(product_id, mime_type)
    
    assert filename.startswith("prod_123_")
    assert filename.endswith(".jpg")
    assert len(filename) > len("prod_123_.jpg")


def test_allowed_mime_types(image_service):
    """Test allowed MIME types configuration"""
    assert "image/jpeg" in image_service.allowed_mime_types
    assert "image/png" in image_service.allowed_mime_types
    assert "image/webp" in image_service.allowed_mime_types
    assert image_service.allowed_mime_types["image/jpeg"] == ".jpg"
    assert image_service.allowed_mime_types["image/png"] == ".png"
    assert image_service.allowed_mime_types["image/webp"] == ".webp"


def test_max_file_size(image_service):
    """Test maximum file size configuration"""
    assert image_service.max_file_size == 5 * 1024 * 1024

@pytest.mark.asyncio
async def test_upload_product_images_batch_success(image_service, mock_product_repository, mock_image_repository):
    """Test batch upload with all files successful."""
    product_id = "prod123"
    mock_product = MagicMock()
    mock_product.id = product_id
    mock_product_repository.get_product_by_id.return_value = mock_product
    
    mock_file1 = MagicMock()
    mock_file1.filename = "test1.jpg"
    mock_file1.read = AsyncMock(return_value=b"fake image data 1")
    
    mock_file2 = MagicMock()
    mock_file2.filename = "test2.png"
    mock_file2.read = AsyncMock(return_value=b"fake image data 2")
    
    mock_image = MagicMock()
    mock_image.id = "img123"
    mock_image.filename = "generated.jpg"
    mock_image.url = "/static/img/generated.jpg"
    mock_image.is_primary = False
    mock_image.uploaded_at = "2023-01-01T00:00:00"
    
    image_service.upload_product_image = AsyncMock(return_value=mock_image)
    
    result = await image_service.upload_product_images_batch(
        product_id=product_id,
        upload_files=[mock_file1, mock_file2],
        make_primary_first=True
    )
    
    assert result["total"] == 2
    assert result["successful_count"] == 2
    assert len(result["success"]) == 2
    assert len(result["failed"]) == 0
    assert image_service.upload_product_image.call_args_list[0][1]['is_primary'] == True
    assert image_service.upload_product_image.call_args_list[1][1]['is_primary'] == False

@pytest.mark.asyncio
async def test_upload_product_images_batch_partial_failure(image_service, mock_product_repository):
    """Test batch upload with some files failing."""
    product_id = "prod123"
    mock_product = MagicMock()
    mock_product.id = product_id
    mock_product_repository.get_product_by_id.return_value = mock_product
    
    mock_file1 = MagicMock()
    mock_file1.filename = "test1.jpg"
    mock_file1.read = AsyncMock(return_value=b"fake image data 1")
    
    mock_file2 = MagicMock()
    mock_file2.filename = "test2.gif"
    mock_file2.read = AsyncMock(return_value=b"fake image data 2")
    
    mock_image = MagicMock()
    mock_image.id = "img123"
    
    from fastapi import HTTPException
    image_service.upload_product_image = AsyncMock(side_effect=[
        mock_image,
        HTTPException(status_code=415, detail="Invalid image format")
    ])
    
    result = await image_service.upload_product_images_batch(
        product_id=product_id,
        upload_files=[mock_file1, mock_file2]
    )
    
    assert result["total"] == 2
    assert result["successful_count"] == 1
    assert len(result["success"]) == 1
    assert len(result["failed"]) == 1
    assert result["failed"][0]["filename"] == "test2.gif"
    assert result["failed"][0]["error"] == "Invalid image format"

@pytest.mark.asyncio
async def test_upload_product_images_batch_product_not_found(image_service, mock_product_repository):
    """Test batch upload for non-existent product."""
    product_id = "nonexistent"
    mock_product_repository.get_product_by_id.return_value = None
    
    mock_file = MagicMock()
    mock_file.filename = "test.jpg"
    
    result = await image_service.upload_product_images_batch(
            product_id=product_id,
            upload_files=[mock_file]
    )
    assert result["successful_count"] == 0
    assert len(result["failed"]) == 1
    assert result["failed"][0]["status_code"] == 404
    
@pytest.mark.asyncio
async def test_upload_product_images_batch_empty_files(image_service):
    """Test batch upload with empty file list."""
    result = await image_service.upload_product_images_batch(
        product_id="prod123",
        upload_files=[]
    )
    
    assert result["total"] == 0
    assert result["successful_count"] == 0
    assert len(result["success"]) == 0
    assert len(result["failed"]) == 0

========================================
File: tests\test_metadata_generator.py
========================================

import pytest
import json
import tempfile
from pathlib import Path
from unittest.mock import Mock, patch
from datetime import datetime

from services.metadata_generator import MetadataGenerator


@pytest.fixture
def temp_storage():
    with tempfile.TemporaryDirectory() as tmpdir:
        yield Path(tmpdir)


@pytest.fixture
def metadata_generator(temp_storage):
    return MetadataGenerator(base_storage_path=temp_storage)


@pytest.fixture
def sample_image_data():
    return {
        "id": "img_123",
        "url": "/static/img/products/prod_456/prod_456_abc123.jpg",
        "is_primary": True,
        "width": 800,
        "height": 600,
        "filename": "prod_456_abc123.jpg",
        "mime_type": "image/jpeg",
        "uploaded_at": "2023-10-01T12:00:00Z"
    }


@pytest.fixture
def sample_product_data():
    return {
        "id": "prod_456",
        "name": "Test Product",
        "images": [],
        "created_at": "2023-10-01T10:00:00Z",
        "updated_at": "2023-10-01T12:00:00Z"
    }


def test_init_creates_directory(temp_storage):
    generator = MetadataGenerator(base_storage_path=temp_storage)
    assert generator.base_storage_path.exists()
    assert generator.metadata_file.parent == generator.base_storage_path


def test_init_with_custom_path():
    with tempfile.TemporaryDirectory() as tmpdir:
        custom_path = Path(tmpdir) / "custom" / "path"
        generator = MetadataGenerator(base_storage_path=custom_path)
        assert generator.base_storage_path == custom_path
        assert generator.metadata_file.parent == custom_path


def test_init_directory_creation_failure():
    with tempfile.TemporaryDirectory() as tmpdir:
        read_only_dir = Path(tmpdir) / "readonly"
        read_only_dir.mkdir()
        
        read_only_file = read_only_dir / "metadata.json"
        read_only_file.write_text("{}")
        read_only_file.chmod(0o444)
        
        generator = MetadataGenerator(base_storage_path=read_only_dir)
        assert generator.base_storage_path == read_only_dir


def test_read_existing_metadata_empty(metadata_generator):
    metadata = metadata_generator._read_existing_metadata()
    assert metadata == {}


def test_read_existing_metadata_with_content(temp_storage):
    metadata_file = temp_storage / "metadata.json"
    test_data = {"test": "data"}
    
    with open(metadata_file, 'w') as f:
        json.dump(test_data, f)
    
    generator = MetadataGenerator(base_storage_path=temp_storage)
    metadata = generator._read_existing_metadata()
    
    assert metadata == test_data


def test_read_existing_metadata_invalid_json(temp_storage):
    metadata_file = temp_storage / "metadata.json"
    
    with open(metadata_file, 'w') as f:
        f.write("invalid json")
    
    generator = MetadataGenerator(base_storage_path=temp_storage)
    
    with pytest.raises(json.JSONDecodeError):
        generator._read_existing_metadata()


def test_read_existing_metadata_permission_error(temp_storage):
    metadata_file = temp_storage / "metadata.json"
    metadata_file.write_text("{}")
    
    metadata_file.chmod(0o400)
    
    generator = MetadataGenerator(base_storage_path=temp_storage)
    
    try:
        metadata = generator._read_existing_metadata()
        assert metadata == {}
    except (PermissionError, OSError, IOError):
        pass
    finally:
        metadata_file.chmod(0o644)


def test_write_metadata_atomic_success(metadata_generator):
    test_metadata = {"product_1": {"name": "Test", "images": []}}
    
    success = metadata_generator._write_metadata_atomic(test_metadata)
    
    assert success is True
    assert metadata_generator.metadata_file.exists()
    
    with open(metadata_generator.metadata_file, 'r') as f:
        loaded = json.load(f)
    
    assert loaded == test_metadata


def test_write_metadata_atomic_failure(metadata_generator):
    with patch('builtins.open', side_effect=IOError("Permission denied")):
        success = metadata_generator._write_metadata_atomic({"test": "data"})
        assert success is False


def test_write_metadata_atomic_json_serialization_error(metadata_generator):
    unjsonable_object = {"circular": []}
    unjsonable_object["circular"].append(unjsonable_object)
    
    success = metadata_generator._write_metadata_atomic({"test": unjsonable_object})
    assert success is False


def test_write_metadata_atomic_directory_creation(metadata_generator):
    import shutil
    
    original_metadata = None
    if metadata_generator.metadata_file.exists():
        original_metadata = metadata_generator._read_existing_metadata()
    
    shutil.rmtree(metadata_generator.base_storage_path)
    
    test_metadata = {"test": "data"}
    success = metadata_generator._write_metadata_atomic(test_metadata)
    
    if success:
        assert metadata_generator.metadata_file.exists()
        assert metadata_generator.base_storage_path.exists()
    else:
        pytest.xfail("Implementation doesn't create directories automatically")
    
    if original_metadata:
        metadata_generator._write_metadata_atomic(original_metadata)


def test_generate_product_metadata_success(metadata_generator, sample_image_data):
    product_id = "prod_456"
    product_name = "Test Product"
    images = [sample_image_data]
    
    success = metadata_generator.generate_product_metadata(
        product_id=product_id,
        product_name=product_name,
        images=images
    )
    
    assert success is True
    
    metadata = metadata_generator._read_existing_metadata()
    assert product_id in metadata
    assert metadata[product_id]["name"] == product_name
    assert metadata[product_id]["images"] == images
    assert "updated_at" in metadata[product_id]


def test_generate_product_metadata_overwrite_existing(metadata_generator, sample_image_data):
    product_id = "prod_456"
    product_name = "Test Product"
    images = [sample_image_data]
    
    metadata_generator.generate_product_metadata(product_id, "Old Name", [])
    
    success = metadata_generator.generate_product_metadata(
        product_id=product_id,
        product_name=product_name,
        images=images
    )
    
    assert success is True
    
    metadata = metadata_generator._read_existing_metadata()
    assert metadata[product_id]["name"] == product_name
    assert metadata[product_id]["images"] == images


def test_generate_product_metadata_empty_images(metadata_generator):
    product_id = "prod_456"
    product_name = "Test Product"
    
    success = metadata_generator.generate_product_metadata(
        product_id=product_id,
        product_name=product_name,
        images=[]
    )
    
    assert success is True
    
    metadata = metadata_generator._read_existing_metadata()
    assert metadata[product_id]["images"] == []


def test_generate_product_metadata_invalid_input(metadata_generator):
    success = metadata_generator.generate_product_metadata(
        product_id="",
        product_name="",
        images=[]
    )
    
    assert success is True


def test_generate_product_metadata_write_failure(metadata_generator, sample_image_data):
    with patch.object(metadata_generator, '_write_metadata_atomic', return_value=False):
        success = metadata_generator.generate_product_metadata(
            product_id="prod_456",
            product_name="Test Product",
            images=[sample_image_data]
        )
        
        assert success is False


def test_update_product_images_add_operation(metadata_generator, sample_image_data):
    product_id = "prod_456"
    product_name = "Test Product"
    
    success = metadata_generator.update_product_images(
        product_id=product_id,
        product_name=product_name,
        image_data=sample_image_data,
        operation="add"
    )
    
    assert success is True
    
    metadata = metadata_generator._read_existing_metadata()
    assert product_id in metadata
    assert metadata[product_id]["name"] == product_name
    assert len(metadata[product_id]["images"]) == 1
    assert metadata[product_id]["images"][0] == sample_image_data


def test_update_product_images_remove_operation(metadata_generator, sample_image_data):
    product_id = "prod_456"
    product_name = "Test Product"
    
    metadata_generator.update_product_images(
        product_id=product_id,
        product_name=product_name,
        image_data=sample_image_data,
        operation="add"
    )
    
    success = metadata_generator.update_product_images(
        product_id=product_id,
        product_name=product_name,
        image_data={"id": "img_123"},
        operation="remove"
    )
    
    assert success is True
    
    metadata = metadata_generator._read_existing_metadata()
    assert len(metadata[product_id]["images"]) == 0


def test_update_product_images_update_primary_operation(metadata_generator):
    product_id = "prod_456"
    product_name = "Test Product"
    
    image1 = {"id": "img_1", "url": "/img1.jpg", "is_primary": True}
    image2 = {"id": "img_2", "url": "/img2.jpg", "is_primary": False}
    
    metadata_generator.update_product_images(
        product_id=product_id,
        product_name=product_name,
        image_data=image1,
        operation="add"
    )
    
    metadata_generator.update_product_images(
        product_id=product_id,
        product_name=product_name,
        image_data=image2,
        operation="add"
    )
    
    metadata_generator.update_product_images(
        product_id=product_id,
        product_name=product_name,
        image_data={"id": "img_2"},
        operation="update_primary"
    )
    
    metadata = metadata_generator._read_existing_metadata()
    images = metadata[product_id]["images"]
    
    assert len(images) == 2
    assert images[0]["is_primary"] is False
    assert images[1]["is_primary"] is True


def test_update_product_images_invalid_operation(metadata_generator):
    product_id = "prod_456"
    product_name = "Test Product"
    
    with patch.object(metadata_generator, '_write_metadata_atomic', return_value=True):
        success = metadata_generator.update_product_images(
            product_id=product_id,
            product_name=product_name,
            image_data={"id": "img_1"},
            operation="invalid_operation"
        )
        
        assert success is True


def test_update_product_images_empty_image_data(metadata_generator):
    product_id = "prod_456"
    product_name = "Test Product"
    
    success = metadata_generator.update_product_images(
        product_id=product_id,
        product_name=product_name,
        image_data={},
        operation="add"
    )
    
    assert success is True
    
    metadata = metadata_generator._read_existing_metadata()
    assert len(metadata[product_id]["images"]) == 1


def test_update_product_images_missing_id_in_remove(metadata_generator):
    product_id = "prod_456"
    product_name = "Test Product"
    
    metadata_generator.update_product_images(
        product_id=product_id,
        product_name=product_name,
        image_data={"id": "img_1", "url": "/img1.jpg", "is_primary": True},
        operation="add"
    )
    
    success = metadata_generator.update_product_images(
        product_id=product_id,
        product_name=product_name,
        image_data={"url": "/img2.jpg"},
        operation="remove"
    )
    
    assert success is True
    
    metadata = metadata_generator._read_existing_metadata()
    assert len(metadata[product_id]["images"]) == 1


def test_update_product_images_write_failure(metadata_generator, sample_image_data):
    with patch.object(metadata_generator, '_write_metadata_atomic', return_value=False):
        success = metadata_generator.update_product_images(
            product_id="prod_456",
            product_name="Test Product",
            image_data=sample_image_data,
            operation="add"
        )
        
        assert success is False


def test_remove_product_success(metadata_generator):
    product_id = "prod_456"
    product_name = "Test Product"
    
    metadata_generator.update_product_images(
        product_id=product_id,
        product_name=product_name,
        image_data={"id": "img_1", "url": "/img1.jpg", "is_primary": True},
        operation="add"
    )
    
    success = metadata_generator.remove_product(product_id)
    
    assert success is True
    
    metadata = metadata_generator._read_existing_metadata()
    assert product_id not in metadata


def test_remove_product_not_found(metadata_generator):
    success = metadata_generator.remove_product("non_existent")
    assert success is True


def test_remove_product_write_failure(metadata_generator):
    product_id = "prod_456"
    product_name = "Test Product"
    
    metadata_generator.update_product_images(
        product_id=product_id,
        product_name=product_name,
        image_data={"id": "img_1", "url": "/img1.jpg", "is_primary": True},
        operation="add"
    )
    
    with patch.object(metadata_generator, '_write_metadata_atomic', return_value=False):
        success = metadata_generator.remove_product(product_id)
        assert success is False


def test_get_product_metadata(metadata_generator):
    product_id = "prod_456"
    product_name = "Test Product"
    
    metadata_generator.update_product_images(
        product_id=product_id,
        product_name=product_name,
        image_data={"id": "img_1", "url": "/img1.jpg", "is_primary": True},
        operation="add"
    )
    
    metadata = metadata_generator.get_product_metadata(product_id)
    
    assert metadata["id"] == product_id
    assert metadata["name"] == product_name
    assert len(metadata["images"]) == 1


def test_get_product_metadata_not_found(metadata_generator):
    metadata = metadata_generator.get_product_metadata("non_existent")
    assert metadata == {}


def test_get_product_metadata_read_error(metadata_generator):
    with patch.object(metadata_generator, '_read_existing_metadata', side_effect=Exception("Read error")):
        metadata = metadata_generator.get_product_metadata("prod_456")
        assert metadata == {}


def test_get_all_metadata(metadata_generator):
    metadata_generator.update_product_images(
        product_id="prod_1",
        product_name="Product 1",
        image_data={"id": "img_1", "url": "/img1.jpg", "is_primary": True},
        operation="add"
    )
    
    metadata_generator.update_product_images(
        product_id="prod_2",
        product_name="Product 2",
        image_data={"id": "img_2", "url": "/img2.jpg", "is_primary": True},
        operation="add"
    )
    
    all_metadata = metadata_generator.get_all_metadata()
    
    assert len(all_metadata) == 2
    assert "prod_1" in all_metadata
    assert "prod_2" in all_metadata


def test_get_all_metadata_read_error(metadata_generator):
    with patch.object(metadata_generator, '_read_existing_metadata', side_effect=Exception("Read error")):
        all_metadata = metadata_generator.get_all_metadata()
        assert all_metadata == {}


def test_validate_metadata_schema_valid(metadata_generator):
    valid_metadata = {
        "prod_1": {
            "id": "prod_1",
            "name": "Product 1",
            "images": [
                {"id": "img_1", "url": "/img1.jpg", "is_primary": True}
            ],
            "updated_at": "2023-10-01T12:00:00Z"
        }
    }
    
    with open(metadata_generator.metadata_file, 'w') as f:
        json.dump(valid_metadata, f)
    
    is_valid = metadata_generator.validate_metadata_schema()
    assert is_valid is True


def test_validate_metadata_schema_missing_field(metadata_generator):
    invalid_metadata = {
        "prod_1": {
            "id": "prod_1",
            "name": "Product 1",
            "images": [
                {"id": "img_1", "url": "/img1.jpg"}  # Missing is_primary
            ],
            "updated_at": "2023-10-01T12:00:00Z"
        }
    }
    
    with open(metadata_generator.metadata_file, 'w') as f:
        json.dump(invalid_metadata, f)
    
    is_valid = metadata_generator.validate_metadata_schema()
    assert is_valid is False


def test_validate_metadata_schema_invalid_json(metadata_generator):
    with open(metadata_generator.metadata_file, 'w') as f:
        f.write("invalid json")
    
    is_valid = metadata_generator.validate_metadata_schema()
    assert is_valid is False


def test_validate_metadata_schema_read_error(metadata_generator):
    with patch.object(metadata_generator, '_read_existing_metadata', side_effect=Exception("Read error")):
        is_valid = metadata_generator.validate_metadata_schema()
        assert is_valid is False


def test_atomic_write_preserves_data(temp_storage):
    generator = MetadataGenerator(base_storage_path=temp_storage)
    
    initial_data = {"prod_1": {"name": "Test", "images": []}}
    
    generator._write_metadata_atomic(initial_data)
    
    assert generator.metadata_file.exists()
    
    with open(generator.metadata_file, 'r') as f:
        loaded = json.load(f)
    
    assert loaded == initial_data
    
    updated_data = {"prod_1": {"name": "Updated", "images": []}}
    generator._write_metadata_atomic(updated_data)
    
    with open(generator.metadata_file, 'r') as f:
        loaded = json.load(f)
    
    assert loaded == updated_data
    assert loaded != initial_data


def test_metadata_file_path_correct(metadata_generator):
    expected_path = metadata_generator.base_storage_path / "metadata.json"
    assert metadata_generator.metadata_file == expected_path


if __name__ == "__main__":
    pytest.main([__file__, "-v"])

========================================
File: tests\test_products_database_connection.py
========================================

import asyncio
import logging
from database.connection import MongoDBConnection, get_products_collection

logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger(__name__)

async def test_connection():
    """Test basic connection functionality"""
    connection = MongoDBConnection()
    
    try:
        print("Testing MongoDB connection...")
        await connection.connect()
        print("✓ Connection successful")
        
        collection = connection.get_collection()
        print(f"✓ Collection retrieved: {collection}")
        
        result = await collection.find_one()
        print(f"✓ Basic find_one operation worked: {result is not None}")
        
        await connection.close()
        print("✓ Connection closed properly")
        
    except Exception as e:
        print(f"✗ Connection test failed: {e}")
        return False
    
    return True

async def test_get_products_collection():
    """Test the helper function"""
    try:
        print("\nTesting get_products_collection...")
        collection = await get_products_collection()
        print(f"✓ get_products_collection worked: {collection}")
        
        # Test count as a simple operation
        count = await collection.count_documents({})
        print(f"✓ Collection count: {count}")
        
        return True
    except Exception as e:
        print(f"✗ get_products_collection failed: {e}")
        return False

async def test_index_operations():
    """Test that indexes are working"""
    connection = MongoDBConnection()
    
    try:
        await connection.connect()
        collection = connection.get_collection()
        
        # List indexes to verify they were created
        indexes = await collection.list_indexes().to_list(length=None)
        print(f"\n✓ Indexes found: {len(indexes)}")
        for idx in indexes:
            print(f"  - {idx['name']}")
            
        await connection.close()
        return True
    except Exception as e:
        print(f"✗ Index test failed: {e}")
        return False

async def main():
    """Run all tests"""
    print("Starting async MongoDB tests...")
    
    tests = [
        test_connection(),
        test_get_products_collection(),
        test_index_operations()
    ]
    
    results = await asyncio.gather(*tests, return_exceptions=True)
    
    print(f"\n=== Test Results ===")
    for i, result in enumerate(results):
        test_name = ["Connection", "Get Collection", "Indexes"][i]
        status = "PASS" if result is True else "FAIL"
        print(f"{test_name}: {status}")
    
    if all(results):
        print("\n🎉 All tests passed!")
    else:
        print("\n❌ Some tests failed")

if __name__ == "__main__":
    asyncio.run(main())

========================================
File: tests\test_products_repository.py
========================================

import pytest
import asyncio
import os
import time
from motor.motor_asyncio import AsyncIOMotorClient
from database.connection import MongoDBConnection
from repositories.product_repository import ProductRepository
from database.database_models import ProductDB

TEST_DB_NAME = "test_product_db"
TEST_CONNECTION_STRING = os.getenv("TEST_MONGODB_URI", "mongodb://localhost:27017/")

@pytest.fixture(scope="function")
async def test_db_setup():
    connection = MongoDBConnection()
    await connection.connect(TEST_CONNECTION_STRING, TEST_DB_NAME)
    collection = connection.get_collection()
    
    await collection.delete_many({})
    
    test_products = [
        {
            "_id": "prod_1",
            "name": "Laptop",
            "description": "High-performance laptop",
            "price": 999.99,
            "stock": 10,
            "tags": ["electronics", "computers"],
            "image_ids": [],
            "primary_image_id": None,
            "created_at": "2023-01-01T00:00:00",
            "updated_at": "2023-01-01T00:00:00"
        },
        {
            "_id": "prod_2", 
            "name": "Mouse",
            "description": "Wireless mouse",
            "price": 29.99,
            "stock": 50,
            "tags": ["electronics", "accessories"],
            "image_ids": [],
            "primary_image_id": None,
            "created_at": "2023-01-02T00:00:00",
            "updated_at": "2023-01-02T00:00:00"
        },
        {
            "_id": "prod_3",
            "name": "Desk",
            "description": "Wooden desk",
            "price": 199.99,
            "stock": 5,
            "tags": ["furniture", "office"],
            "image_ids": [],
            "primary_image_id": None,
            "created_at": "2023-01-03T00:00:00", 
            "updated_at": "2023-01-03T00:00:00"
        }
    ]
    
    await collection.insert_many(test_products)
    
    repository = ProductRepository(collection=collection)
    
    yield repository, connection, collection
    
    await collection.delete_many({})
    await connection.close()

@pytest.mark.asyncio
async def test_create_product_success(test_db_setup):
    repository, connection, collection = test_db_setup
    
    new_product = ProductDB(
        id="prod_4",
        name="Keyboard",
        description="Mechanical keyboard",
        price=79.99,
        stock=25,
        tags=["electronics", "accessories"]
    )
    
    result = await repository.create_product(new_product)
    
    assert result is not None
    assert result.name == "Keyboard"
    assert result.price == 79.99
    
    fetched = await repository.get_product_by_id("prod_4")
    assert fetched.name == "Keyboard"

@pytest.mark.asyncio
async def test_create_product_duplicate_name(test_db_setup):
    repository, connection, collection = test_db_setup
    
    duplicate_product = ProductDB(
        id="prod_5",
        name="Laptop",
        description="Another laptop",
        price=899.99,
        stock=5
    )
    
    result = await repository.create_product(duplicate_product)
    assert result is None

@pytest.mark.asyncio
async def test_get_product_by_id_success(test_db_setup):
    repository, connection, collection = test_db_setup
    
    result = await repository.get_product_by_id("prod_1")
    
    assert result is not None
    assert result.id == "prod_1"
    assert result.name == "Laptop"
    assert result.price == 999.99

@pytest.mark.asyncio
async def test_get_product_by_id_not_found(test_db_setup):
    repository, connection, collection = test_db_setup
    
    result = await repository.get_product_by_id("non_existent")
    assert result is None

@pytest.mark.asyncio
async def test_get_product_by_name(test_db_setup):
    repository, connection, collection = test_db_setup
    
    result = await repository.get_product_by_name("Mouse")
    
    assert result is not None
    assert result.name == "Mouse"
    assert result.price == 29.99

@pytest.mark.asyncio
async def test_list_products_basic(test_db_setup):
    repository, connection, collection = test_db_setup
    
    products = await repository.list_products(skip=0, limit=2)
    
    assert len(products) == 2
    assert products[0].name == "Desk"
    assert products[1].name == "Mouse"

@pytest.mark.asyncio
async def test_list_products_with_search(test_db_setup):
    repository, connection, collection = test_db_setup
    
    products = await repository.list_products(
        skip=0, 
        limit=10, 
        search_query="laptop"
    )
    
    assert len(products) == 1
    assert products[0].name == "Laptop"

@pytest.mark.asyncio
async def test_list_products_with_tags(test_db_setup):
    repository, connection, collection = test_db_setup
    
    products = await repository.list_products(
        skip=0,
        limit=10,
        tags=["electronics"]
    )
    
    assert len(products) == 2
    product_names = [p.name for p in products]
    assert "Laptop" in product_names
    assert "Mouse" in product_names

@pytest.mark.asyncio
async def test_count_products(test_db_setup):
    repository, connection, collection = test_db_setup
    
    count = await repository.count_products()
    assert count == 3

@pytest.mark.asyncio
async def test_count_products_with_search(test_db_setup):
    repository, connection, collection = test_db_setup
    
    count = await repository.count_products(search_query="wireless")
    assert count == 1

@pytest.mark.asyncio
async def test_update_product_success(test_db_setup):
    repository, connection, collection = test_db_setup
    
    update_data = {
        "name": "Gaming Laptop",
        "price": 1299.99,
        "stock": 8
    }
    
    result = await repository.update_product("prod_1", update_data)
    
    assert result is not None
    assert result.name == "Gaming Laptop"
    assert result.price == 1299.99
    assert result.stock == 8

@pytest.mark.asyncio
async def test_update_product_not_found(test_db_setup):
    repository, connection, collection = test_db_setup
    
    result = await repository.update_product("non_existent", {"name": "Test"})
    assert result is None

@pytest.mark.asyncio
async def test_delete_product_success(test_db_setup):
    repository, connection, collection = test_db_setup
    
    result = await repository.delete_product("prod_1")
    assert result is True
    
    fetched = await repository.get_product_by_id("prod_1")
    assert fetched is None

@pytest.mark.asyncio
async def test_delete_product_not_found(test_db_setup):
    repository, connection, collection = test_db_setup
    
    result = await repository.delete_product("non_existent")
    assert result is False

@pytest.mark.asyncio
async def test_update_inventory(test_db_setup):
    repository, connection, collection = test_db_setup
    
    result = await repository.update_inventory("prod_1", 15)
    assert result is not None
    assert result.stock == 15

@pytest.mark.asyncio
async def test_get_products_by_tags(test_db_setup):
    repository, connection, collection = test_db_setup
    
    products = await repository.get_products_by_tags(["electronics"])
    assert len(products) == 2
    assert all("electronics" in product.tags for product in products)

@pytest.mark.asyncio
async def test_get_popular_tags(test_db_setup):
    repository, connection, collection = test_db_setup
    
    popular_tags = await repository.get_popular_tags(limit=5)
    assert len(popular_tags) > 0
    tag_names = [tag["tag"] for tag in popular_tags]
    assert "electronics" in tag_names

@pytest.mark.asyncio
async def test_tag_query_performance(test_db_setup):
    repository, connection, collection = test_db_setup
    
    await collection.create_index("tags")
    
    start_time = time.time()
    
    for _ in range(100):
        cursor = collection.find({"tags": "electronics"})
        results = await cursor.to_list(length=100)
    
    end_time = time.time()
    query_time = end_time - start_time
    
    print(f"Tag query time for 100 iterations: {query_time:.4f} seconds")
    assert query_time < 2.0

@pytest.mark.asyncio
async def test_search_query_performance(test_db_setup):
    repository, connection, collection = test_db_setup
    
    start_time = time.time()
    
    for _ in range(100):
        cursor = collection.find({
            "$or": [
                {"name": {"$regex": "laptop", "$options": "i"}},
                {"description": {"$regex": "wireless", "$options": "i"}}
            ]
        })
        results = await cursor.to_list(length=100)
    
    end_time = time.time()
    query_time = end_time - start_time
    
    print(f"Search query time for 100 iterations: {query_time:.4f} seconds")
    assert query_time < 2.0

@pytest.mark.asyncio
async def test_index_effectiveness(test_db_setup):
    repository, connection, collection = test_db_setup
    
    await collection.delete_many({})
    
    bulk_data = []
    for i in range(5000):
        bulk_data.append({
            "_id": f"prod_{i}",
            "name": f"Product {i}",
            "description": f"Description {i}",
            "price": i * 10.0,
            "stock": i % 100,
            "tags": ["electronics"] if i % 10 == 0 else ["furniture"],
            "image_ids": [],
            "primary_image_id": None,
            "created_at": "2023-01-01T00:00:00",
            "updated_at": "2023-01-01T00:00:00"
        })
    
    await collection.insert_many(bulk_data)
    
    await collection.drop_indexes()
    
    start_time = time.time()
    for _ in range(10):
        cursor = collection.find({"tags": "electronics"})
        results = await cursor.to_list(length=1000)
    time_without_index = time.time() - start_time
    
    await collection.create_index([("tags", 1)])
    
    start_time = time.time()
    for _ in range(10):
        cursor = collection.find({"tags": "electronics"})
        results = await cursor.to_list(length=1000)
    time_with_index = time.time() - start_time
    
    improvement = ((time_without_index - time_with_index) / time_without_index) * 100
    print(f"Without index: {time_without_index:.4f}s, With index: {time_with_index:.4f}s, Improvement: {improvement:.1f}%")
    
    assert time_with_index < time_without_index

@pytest.mark.asyncio
async def test_add_image_to_product_success(test_db_setup):
    repository, connection, collection = test_db_setup
    
    result = await repository.add_image_to_product("prod_1", "img_123")
    
    assert result is not None
    assert "img_123" in result.image_ids

@pytest.mark.asyncio
async def test_add_image_to_product_not_found(test_db_setup):
    repository, connection, collection = test_db_setup
    
    result = await repository.add_image_to_product("non_existent", "img_123")
    assert result is None

@pytest.mark.asyncio
async def test_remove_image_from_product_success(test_db_setup):
    repository, connection, collection = test_db_setup
    
    await repository.add_image_to_product("prod_1", "img_123")
    await repository.add_image_to_product("prod_1", "img_456")
    
    result = await repository.remove_image_from_product("prod_1", "img_123")
    
    assert result is not None
    assert "img_123" not in result.image_ids
    assert "img_456" in result.image_ids

@pytest.mark.asyncio
async def test_remove_image_clears_primary_image(test_db_setup):
    repository, connection, collection = test_db_setup
    
    await repository.add_image_to_product("prod_1", "img_123")
    await repository.set_primary_image("prod_1", "img_123")
    
    product_before = await repository.get_product_by_id("prod_1")
    assert product_before.primary_image_id == "img_123"
    
    result = await repository.remove_image_from_product("prod_1", "img_123")
    
    assert result is not None
    assert result.primary_image_id is None

@pytest.mark.asyncio
async def test_remove_image_from_product_not_found(test_db_setup):
    repository, connection, collection = test_db_setup
    
    result = await repository.remove_image_from_product("non_existent", "img_123")
    assert result is None

@pytest.mark.asyncio
async def test_set_primary_image_success(test_db_setup):
    repository, connection, collection = test_db_setup
    
    await repository.add_image_to_product("prod_1", "img_123")
    
    result = await repository.set_primary_image("prod_1", "img_123")
    
    assert result is not None
    assert result.primary_image_id == "img_123"

@pytest.mark.asyncio
async def test_set_primary_image_not_found(test_db_setup):
    repository, connection, collection = test_db_setup
    
    result = await repository.set_primary_image("non_existent", "img_123")
    assert result is None

@pytest.mark.asyncio
async def test_set_primary_image_image_not_in_product(test_db_setup):
    repository, connection, collection = test_db_setup
    
    result = await repository.set_primary_image("prod_1", "img_123")
    assert result is None

@pytest.mark.asyncio
async def test_product_creation_with_image_fields(test_db_setup):
    repository, connection, collection = test_db_setup
    
    new_product = ProductDB(
        id="prod_4",
        name="Camera",
        description="Digital camera",
        price=299.99,
        stock=8,
        tags=["electronics", "photography"],
        image_ids=["img_1", "img_2"],
        primary_image_id="img_1"
    )
    
    result = await repository.create_product(new_product)
    
    assert result is not None
    assert result.image_ids == ["img_1", "img_2"]
    assert result.primary_image_id == "img_1"
    
    fetched = await repository.get_product_by_id("prod_4")
    assert fetched.image_ids == ["img_1", "img_2"]
    assert fetched.primary_image_id == "img_1"

@pytest.mark.asyncio
async def test_backward_compatibility_empty_image_fields(test_db_setup):
    repository, connection, collection = test_db_setup
    
    product = await repository.get_product_by_id("prod_1")
    
    assert product.image_ids == []
    assert product.primary_image_id is None

if __name__ == "__main__":
    import asyncio
    
    async def run_tests():
        connection = MongoDBConnection()
        await connection.connect(TEST_CONNECTION_STRING, TEST_DB_NAME)
        collection = connection.get_collection()
        await collection.delete_many({})
        
        repo = ProductRepository(collection=collection)
        
        test_product = ProductDB(
            id="manual_test_1",
            name="Test Product",
            description="Test Description",
            price=100.0,
            stock=10,
            tags=["test"]
        )
        
        result = await repo.create_product(test_product)
        print(f"Create product: {'SUCCESS' if result else 'FAILED'}")
        
        fetched = await repo.get_product_by_id("manual_test_1")
        print(f"Get product: {'SUCCESS' if fetched else 'FAILED'}")
        
        await collection.delete_many({})
        await connection.close()
    
    asyncio.run(run_tests())

========================================
File: tests\test_product_contract.py
========================================

import pytest
import asyncio
from fastapi.testclient import TestClient
from fastapi import FastAPI
from unittest.mock import Mock, AsyncMock
from services.product_services import ProductService
from database import pydantic_models
from database.database_models import ProductDB
from routes.product_routes import router, get_product_service
import logging
from database.pydantic_models import ProductImage

app = FastAPI()
app.include_router(router, prefix="/api/products")

@pytest.fixture
def mock_product_service():
    service = Mock(spec=ProductService)
    service.create_product = AsyncMock()
    service.get_product = AsyncMock()
    service.list_products = AsyncMock()
    service.update_product = AsyncMock()
    service.patch_product = AsyncMock()
    service.delete_product = AsyncMock()
    service.update_inventory = AsyncMock()
    return service

@pytest.fixture
def client(mock_product_service):
    app.dependency_overrides[get_product_service] = lambda: mock_product_service
    with TestClient(app) as test_client:
        yield test_client
    app.dependency_overrides.clear()

@pytest.fixture
def sample_product_data():
    return {
        "name": "Test Product",
        "price": 99.99,
        "stock": 10,
        "description": "Test Description"
    }

@pytest.fixture
def sample_product_response():
    return {
        "id": "prod_123",
        "name": "Test Product",
        "price": 99.99,
        "stock": 10,
        "description": "Test Description",
        "images": [],
        "primary_image_id": None
    }

class TestProductRoutesContract:
    def test_create_product_success(self, client, mock_product_service, sample_product_data, sample_product_response):
        from fastapi.responses import JSONResponse
        
        create_response = sample_product_response.copy()
        del create_response["images"]
        del create_response["primary_image_id"]
        
        json_response = JSONResponse(
            status_code=201,
            content=create_response,
            headers={"Location": "/api/products/prod_123"}
        )
        mock_product_service.create_product.return_value = json_response
        
        response = client.post("/api/products/create", json=sample_product_data)
        
        assert response.status_code == 201
        assert response.json() == create_response
        assert "Location" in response.headers
        assert "/api/products/prod_123" in response.headers["Location"]
        mock_product_service.create_product.assert_called_once()

    def test_get_product_success(self, client, mock_product_service, sample_product_response):
        
        pydantic_models.ProductResponse.model_rebuild()
        
        mock_response = pydantic_models.ProductResponse(**sample_product_response)
        mock_product_service.get_product.return_value = mock_response
        
        response = client.get("/api/products/prod_123")
        
        assert response.status_code == 200
        assert response.json() == sample_product_response
        mock_product_service.get_product.assert_called_once()

    def test_get_product_not_found(self, client, mock_product_service):
        from services.product_helpers import create_problem_response
        
        problem_response = create_problem_response(
            status_code=404,
            error_type="not-found",
            title="Not Found", 
            detail="Product not found",
            instance="/api/products/non_existent"
        )
        mock_product_service.get_product.return_value = problem_response
        
        response = client.get("/api/products/non_existent")
        
        assert response.status_code == 404
        assert "Not Found" in response.json()["title"]

    def test_list_products_success(self, client, mock_product_service, sample_product_response):
        
        
        pydantic_models.ProductResponse.model_rebuild()
        pydantic_models.ProductList.model_rebuild()
        
        product_list = pydantic_models.ProductList(
            items=[pydantic_models.ProductResponse(**sample_product_response)],
            total=1,
            page=1,
            page_size=20
        )
        mock_product_service.list_products.return_value = product_list
        
        response = client.get("/api/products/")
        
        assert response.status_code == 200
        data = response.json()
        assert data["total"] == 1
        assert data["page"] == 1
        assert len(data["items"]) == 1
        assert data["items"][0] == sample_product_response
        mock_product_service.list_products.assert_called_once()

    def test_list_products_with_pagination(self, client, mock_product_service):
        
        
        pydantic_models.ProductResponse.model_rebuild()
        pydantic_models.ProductList.model_rebuild()
        
        product_list = pydantic_models.ProductList(
            items=[],
            total=0,
            page=2,
            page_size=5
        )
        mock_product_service.list_products.return_value = product_list
        
        response = client.get("/api/products/?page=2&page_size=5")
        
        assert response.status_code == 200
        data = response.json()
        assert data["page"] == 2
        assert data["page_size"] == 5

    def test_list_products_with_search(self, client, mock_product_service):
        
        
        pydantic_models.ProductResponse.model_rebuild()
        pydantic_models.ProductList.model_rebuild()
        
        product_list = pydantic_models.ProductList(
            items=[],
            total=0,
            page=1,
            page_size=20
        )
        mock_product_service.list_products.return_value = product_list
        
        response = client.get("/api/products/?q=laptop")
        
        assert response.status_code == 200
        mock_product_service.list_products.assert_called_once()

    def test_update_product_success(self, client, mock_product_service, sample_product_data, sample_product_response):
        
        
        pydantic_models.ProductResponse.model_rebuild()
        
        mock_response = pydantic_models.ProductResponse(**sample_product_response)
        mock_product_service.update_product.return_value = mock_response
        
        response = client.put("/api/products/prod_123", json=sample_product_data)
        
        assert response.status_code == 200
        assert response.json() == sample_product_response
        mock_product_service.update_product.assert_called_once()

    def test_patch_product_success(self, client, mock_product_service, sample_product_response):
        
        
        pydantic_models.ProductResponse.model_rebuild()
        
        mock_response = pydantic_models.ProductResponse(**sample_product_response)
        mock_product_service.patch_product.return_value = mock_response
        
        patch_data = {"price": 149.99}
        
        response = client.patch("/api/products/prod_123", json=patch_data)
        
        assert response.status_code == 200
        assert response.json() == sample_product_response
        mock_product_service.patch_product.assert_called_once()

    def test_delete_product_success(self, client, mock_product_service):
        mock_product_service.delete_product.return_value = None
        
        response = client.delete("/api/products/prod_123")
        
        assert response.status_code == 204
        mock_product_service.delete_product.assert_called_once()

    def test_update_inventory_success(self, client, mock_product_service):
        inventory_response = pydantic_models.InventoryResponse(
            id="prod_123",
            stock=25
        )
        mock_product_service.update_inventory.return_value = inventory_response
        
        inventory_data = {"stock": 25}
        
        response = client.patch("/api/products/prod_123/inventory", json=inventory_data)
        
        assert response.status_code == 200
        assert response.json() == {"id": "prod_123", "stock": 25}
        mock_product_service.update_inventory.assert_called_once()

    def test_update_inventory_validation_error(self, client):
        invalid_data = {"stock": -5}
        
        response = client.patch("/api/products/prod_123/inventory", json=invalid_data)
        
        assert response.status_code == 422

    def test_invalid_page_parameter(self, client):
        response = client.get("/api/products/?page=0")
        
        assert response.status_code == 422

    def test_invalid_page_size_parameter(self, client):
        response = client.get("/api/products/?page_size=200")
        
        assert response.status_code == 422

    def test_route_not_found(self, client):
        response = client.get("/api/products/nonexistent/route")
        
        assert response.status_code == 404

    def test_method_not_allowed(self, client):
        response = client.post("/api/products/prod_123") 
        
        assert response.status_code == 405

class TestProductRoutesErrorScenarios:
    def test_service_raises_exception(self, client, mock_product_service):
        mock_product_service.get_product.side_effect = Exception("Database error")
        
        response = client.get("/api/products/prod_123")
        
        assert response.status_code == 500

    def test_malformed_json(self, client):
        response = client.post("/api/products/create", data='{"malformed": json')
        
        assert response.status_code == 422

    def test_missing_required_fields(self, client):
        incomplete_data = {"name": "Test"}
        
        response = client.post("/api/products/create", json=incomplete_data)
        
        assert response.status_code == 422

class TestProductRoutesEdgeCases:
    def test_empty_product_list(self, client, mock_product_service):
        
        
        pydantic_models.ProductResponse.model_rebuild()
        pydantic_models.ProductList.model_rebuild()
        
        product_list = pydantic_models.ProductList(
            items=[],
            total=0,
            page=1,
            page_size=20
        )
        mock_product_service.list_products.return_value = product_list
        
        response = client.get("/api/products/")
        
        assert response.status_code == 200
        data = response.json()
        assert data["total"] == 0
        assert data["items"] == []

    def test_special_characters_in_search(self, client, mock_product_service):
        
        
        pydantic_models.ProductResponse.model_rebuild()
        pydantic_models.ProductList.model_rebuild()
        
        product_list = pydantic_models.ProductList(
            items=[],
            total=0,
            page=1,
            page_size=20
        )
        mock_product_service.list_products.return_value = product_list
        
        response = client.get("/api/products/?q=test%20product%20@%23")
        
        assert response.status_code == 200

    def test_long_product_id(self, client, mock_product_service, sample_product_response):
        
        
        pydantic_models.ProductResponse.model_rebuild()
        
        mock_response = pydantic_models.ProductResponse(**sample_product_response)
        mock_product_service.get_product.return_value = mock_response
        
        long_id = "a" * 100
        response = client.get(f"/api/products/{long_id}")
        
        assert response.status_code == 200

class TestProductRoutesContentTypes:
    def test_json_content_type(self, client, mock_product_service, sample_product_response):
        
        
        pydantic_models.ProductResponse.model_rebuild()
        
        mock_response = pydantic_models.ProductResponse(**sample_product_response)
        mock_product_service.get_product.return_value = mock_response
        
        response = client.get("/api/products/prod_123")
        
        assert response.headers["content-type"] == "application/json"

    def test_create_product_content_type(self, client, mock_product_service, sample_product_data, sample_product_response):
        
        
        pydantic_models.ProductResponse.model_rebuild()
        
        create_response = sample_product_response.copy()
        del create_response["images"]
        del create_response["primary_image_id"]
        
        mock_response = pydantic_models.ProductResponse(**create_response)
        mock_product_service.create_product.return_value = mock_response
        
        response = client.post(
            "/api/products/create", 
            json=sample_product_data,
            headers={"Content-Type": "application/json"}
        )
        
        assert response.status_code == 201

    def test_wrong_content_type(self, client):
        response = client.post(
            "/api/products/create",
            data="name=test",
            headers={"Content-Type": "application/x-www-form-urlencoded"}
        )
        
        assert response.status_code == 422

def setup_module():
    """Setup module to resolve Pydantic forward references"""
    
    pydantic_models.ProductResponse.model_rebuild()
    pydantic_models.ProductList.model_rebuild()

if __name__ == "__main__":
    setup_module()
    pytest.main([__file__, "-v"])

========================================
File: tests\test_product_services.py
========================================

import pytest
import asyncio
from unittest.mock import Mock, AsyncMock, patch
from fastapi import Request
from fastapi.responses import JSONResponse

from services.product_services import ProductService
from database import pydantic_models
from database.database_models import ProductDB, ImageDB
from datetime import datetime
from services.product_helpers import create_problem_response

@pytest.fixture
def mock_logger():
    return Mock()

@pytest.fixture
def mock_product_repository():
    repo = Mock()
    repo.create_product = AsyncMock()
    repo.get_product_by_id = AsyncMock()
    repo.get_product_by_name = AsyncMock()
    repo.list_products = AsyncMock()
    repo.count_products = AsyncMock()
    repo.update_product = AsyncMock()
    repo.delete_product = AsyncMock()
    repo.update_inventory = AsyncMock()
    repo.add_image_to_product = AsyncMock()
    repo.remove_image_from_product = AsyncMock()
    repo.set_primary_image = AsyncMock()
    return repo

@pytest.fixture
def mock_image_repository():
    repo = Mock()
    repo.get_image_by_id = AsyncMock()
    return repo

@pytest.fixture
def product_service(mock_logger, mock_product_repository, mock_image_repository):
    service = ProductService(mock_logger)
    service.product_repository = mock_product_repository
    service.image_repository = mock_image_repository
    return service

@pytest.fixture
def mock_request():
    request = Mock(spec=Request)
    request.url = "http://testserver/api/products"
    return request

@pytest.fixture
def sample_product_db():
    return ProductDB(
        id="test_id_123",
        name="Test Product",
        price=99.99,
        stock=10,
        description="Test Description",
        tags=["electronics"],
        image_ids=["img_1", "img_2"],
        primary_image_id="img_1"
    )

@pytest.fixture
def sample_image_data():
    """Returns a proper ImageDB object for testing"""
    return ImageDB(
        id="img_1",
        product_id="test_id_123",
        filename="test_img.jpg",
        original_name="original.jpg",
        mime_type="image/jpeg",
        size=1024000,
        width=800,
        height=600,
        is_primary=True,
        uploaded_at=datetime.utcnow()
    )

@pytest.mark.asyncio
async def test_create_product_success(product_service, mock_request):
    product_data = pydantic_models.ProductRequest(
        name="Test Product",
        price=99.99,
        stock=10,
        description="Test Description"
    )
    
    mock_product = ProductDB(
        id="test_id_123",
        name="Test Product",
        price=99.99,
        stock=10,
        description="Test Description",
        image_ids=[],
        primary_image_id=None
    )
    
    product_service.product_repository.create_product.return_value = mock_product
    
    result = await product_service.create_product(mock_request, product_data)
    
    assert isinstance(result, JSONResponse)
    assert result.status_code == 201
    
    product_service.product_repository.create_product.assert_called_once()
    product_service.logger.info.assert_called()

@pytest.mark.asyncio
async def test_get_product_success(product_service, mock_request, sample_product_db, sample_image_data):
    # Configure the mock to return the sample product
    product_service.product_repository.get_product_by_id.return_value = sample_product_db
    
    # Configure the image repository mock to return actual ImageDB objects
    # Use side_effect to return different values based on input
    async def get_image_side_effect(image_id):
        if image_id == "img_1":
            return sample_image_data
        elif image_id == "img_2":
            return ImageDB(
                id="img_2",
                product_id="test_id_123",
                filename="test_img2.jpg",
                original_name="original2.jpg",
                mime_type="image/jpeg",
                size=512000,
                width=400,
                height=300,
                is_primary=False,
                uploaded_at=datetime.utcnow()
            )
        return None
    
    product_service.image_repository.get_image_by_id.side_effect = get_image_side_effect
    
    result = await product_service.get_product(mock_request, "test_id_123")
    
    # Check result is ProductResponse (not JSONResponse for errors)
    assert hasattr(result, 'id')
    assert result.id == "test_id_123"
    assert result.name == "Test Product"
    assert result.price == 99.99
    assert result.images is not None
    assert len(result.images) == 2
    assert result.primary_image_id == "img_1"
    
    product_service.product_repository.get_product_by_id.assert_called_once_with("test_id_123")
    assert product_service.image_repository.get_image_by_id.call_count == 2

@pytest.mark.asyncio
async def test_get_product_no_images(product_service, mock_request):
    product_without_images = ProductDB(
        id="test_id_123",
        name="Test Product",
        price=99.99,
        stock=10,
        description="Test Description",
        image_ids=[],
        primary_image_id=None
    )
    
    product_service.product_repository.get_product_by_id.return_value = product_without_images
    
    result = await product_service.get_product(mock_request, "test_id_123")
    
    assert hasattr(result, 'id')
    assert result.id == "test_id_123"
    assert result.images == []
    assert result.primary_image_id is None
    
    product_service.image_repository.get_image_by_id.assert_not_called()

@pytest.mark.asyncio
async def test_get_product_image_not_found(product_service, mock_request, sample_product_db):
    product_service.product_repository.get_product_by_id.return_value = sample_product_db
    product_service.image_repository.get_image_by_id.return_value = None
    
    result = await product_service.get_product(mock_request, "test_id_123")
    
    assert hasattr(result, 'id')
    assert result.id == "test_id_123"
    assert result.images == []  # Should be empty since no images found
    assert result.primary_image_id == "img_1"

@pytest.mark.asyncio
async def test_get_product_not_found(product_service, mock_request):
    product_service.product_repository.get_product_by_id.return_value = None
    
    result = await product_service.get_product(mock_request, "non_existent_id")
    
    assert isinstance(result, JSONResponse)
    assert result.status_code == 404
    assert "Not Found" in result.body.decode()

@pytest.mark.asyncio
async def test_list_products_success(product_service, mock_request):
    mock_products = [
        ProductDB(
            id="prod_1",
            name="Product 1",
            price=99.99,
            stock=10,
            description="Description 1",
            image_ids=["img_1"],
            primary_image_id="img_1"
        ),
        ProductDB(
            id="prod_2",
            name="Product 2",
            price=199.99,
            stock=5,
            description="Description 2",
            image_ids=[],
            primary_image_id=None
        )
    ]
    
    mock_image = ImageDB(
        id="img_1",
        product_id="prod_1",
        filename="prod1_img.jpg",
        original_name="original.jpg",
        mime_type="image/jpeg",
        size=1024000,
        width=800,
        height=600,
        is_primary=True,
        uploaded_at=datetime.utcnow()
    )
    
    product_service.product_repository.list_products.return_value = mock_products
    product_service.product_repository.count_products.return_value = 2
    
    # Configure image repository to return the mock image
    async def get_image_side_effect(image_id):
        if image_id == "img_1":
            return mock_image
        return None
    
    product_service.image_repository.get_image_by_id.side_effect = get_image_side_effect
    
    query_params = pydantic_models.ProductQueryParams(
        page=1,
        page_size=10,
        q=None
    )
    
    result = await product_service.list_products(mock_request, query_params)
    
    assert result.total == 2
    assert len(result.items) == 2
    assert result.page == 1
    assert result.page_size == 10
    
    assert result.items[0].name == "Product 1"
    assert len(result.items[0].images) == 1
    assert result.items[0].primary_image_id == "img_1"
    
    assert result.items[1].name == "Product 2"
    assert result.items[1].images == []
    assert result.items[1].primary_image_id is None
    
    product_service.product_repository.list_products.assert_called_with(
        skip=0, limit=10, search_query=None
    )

@pytest.mark.asyncio
async def test_list_products_with_search(product_service, mock_request):
    product_service.product_repository.list_products.return_value = []
    product_service.product_repository.count_products.return_value = 0
    
    query_params = pydantic_models.ProductQueryParams(
        page=1,
        page_size=10,
        q="laptop"
    )
    
    result = await product_service.list_products(mock_request, query_params)
    
    assert result.total == 0
    assert result.items == []
    
    product_service.product_repository.list_products.assert_called_with(
        skip=0, limit=10, search_query="laptop"
    )

@pytest.mark.asyncio
async def test_list_products_pagination(product_service, mock_request):
    product_service.product_repository.list_products.return_value = []
    product_service.product_repository.count_products.return_value = 50
    
    query_params = pydantic_models.ProductQueryParams(
        page=2,
        page_size=10,
        q=None
    )
    
    result = await product_service.list_products(mock_request, query_params)
    
    assert result.total == 50
    assert result.page == 2
    assert result.page_size == 10
    
    product_service.product_repository.list_products.assert_called_with(
        skip=10, limit=10, search_query=None
    )

@pytest.mark.asyncio
async def test_update_product_success(product_service, mock_request, sample_product_db, sample_image_data):
    # Configure the product repository to return the updated product
    product_service.product_repository.update_product.return_value = sample_product_db
    
    # Configure the image repository to return actual ImageDB objects
    async def get_image_side_effect(image_id):
        if image_id == "img_1":
            return sample_image_data
        elif image_id == "img_2":
            return ImageDB(
                id="img_2",
                product_id="test_id_123",
                filename="test_img2.jpg",
                original_name="original2.jpg",
                mime_type="image/jpeg",
                size=512000,
                width=400,
                height=300,
                is_primary=False,
                uploaded_at=datetime.utcnow()
            )
        return None
    
    product_service.image_repository.get_image_by_id.side_effect = get_image_side_effect
    
    update_data = pydantic_models.ProductRequest(
        name="Updated Product",
        price=149.99,
        stock=15,
        description="Updated Description"
    )
    
    result = await product_service.update_product(mock_request, "test_id_123", update_data)
    
    # Check that we got a ProductResponse, not an error
    assert hasattr(result, 'name')
    assert result.name == "Test Product"  # Should be from sample_product_db
    assert result.price == 99.99
    assert result.stock == 10
    
    product_service.product_repository.update_product.assert_called_once()

@pytest.mark.asyncio
async def test_update_product_not_found(product_service, mock_request):
    product_service.product_repository.update_product.return_value = None
    
    update_data = pydantic_models.ProductRequest(
        name="Updated Product",
        price=149.99,
        stock=15,
        description="Updated Description"
    )
    
    result = await product_service.update_product(mock_request, "non_existent_id", update_data)
    
    assert isinstance(result, JSONResponse)
    assert result.status_code == 404
    assert "Not Found" in result.body.decode()

@pytest.mark.asyncio
async def test_patch_product_success(product_service, mock_request, sample_product_db, sample_image_data):
    # Configure the product repository to return the patched product
    product_service.product_repository.update_product.return_value = sample_product_db
    
    # Configure the image repository to return actual ImageDB objects
    async def get_image_side_effect(image_id):
        if image_id == "img_1":
            return sample_image_data
        elif image_id == "img_2":
            return ImageDB(
                id="img_2",
                product_id="test_id_123",
                filename="test_img2.jpg",
                original_name="original2.jpg",
                mime_type="image/jpeg",
                size=512000,
                width=400,
                height=300,
                is_primary=False,
                uploaded_at=datetime.utcnow()
            )
        return None
    
    product_service.image_repository.get_image_by_id.side_effect = get_image_side_effect
    
    patch_data = pydantic_models.ProductPatch(price=199.99)
    
    result = await product_service.patch_product(mock_request, "test_id_123", patch_data)
    
    assert hasattr(result, 'price')
    assert result.price == 99.99  # Should be from sample_product_db
    assert result.name == "Test Product"
    
    product_service.product_repository.update_product.assert_called_once()

@pytest.mark.asyncio
async def test_patch_product_not_found(product_service, mock_request):
    product_service.product_repository.update_product.return_value = None
    
    patch_data = pydantic_models.ProductPatch(price=199.99)
    
    result = await product_service.patch_product(mock_request, "non_existent_id", patch_data)
    
    assert isinstance(result, JSONResponse)
    assert result.status_code == 404
    assert "Not Found" in result.body.decode()

@pytest.mark.asyncio
async def test_delete_product_success(product_service, mock_request, sample_product_db):
    product_service.product_repository.get_product_by_id.return_value = sample_product_db
    product_service.product_repository.delete_product.return_value = True
    
    with patch('services.image_services.ImageService') as mock_image_service_class:
        mock_image_service = Mock()
        mock_image_service.delete_product_image = AsyncMock()
        mock_image_service_class.return_value = mock_image_service
        
        result = await product_service.delete_product(mock_request, "test_id_123")
        
        assert result is None
        product_service.product_repository.delete_product.assert_called_once_with("test_id_123")
        product_service.logger.info.assert_called()

@pytest.mark.asyncio
async def test_delete_product_not_found(product_service, mock_request):
    product_service.product_repository.delete_product.return_value = False
    
    result = await product_service.delete_product(mock_request, "non_existent_id")
    
    assert isinstance(result, JSONResponse)
    assert result.status_code == 404
    assert "Not Found" in result.body.decode()

@pytest.mark.asyncio
async def test_delete_product_with_images_error(product_service, mock_request, sample_product_db):
    product_service.product_repository.get_product_by_id.return_value = sample_product_db
    product_service.product_repository.delete_product.return_value = True
    
    with patch('services.image_services.ImageService') as mock_image_service_class:
        mock_image_service = Mock()
        mock_image_service.delete_product_image = AsyncMock(side_effect=Exception("Image delete failed"))
        mock_image_service_class.return_value = mock_image_service
        
        result = await product_service.delete_product(mock_request, "test_id_123")
        
        assert result is None
        product_service.logger.error.assert_called()

@pytest.mark.asyncio
async def test_update_inventory_success(product_service, mock_request):
    mock_updated_product = ProductDB(
        id="test_id_123",
        name="Test Product",
        price=99.99,
        stock=25,
        description="Test Description",
        image_ids=[],
        primary_image_id=None
    )
    
    product_service.product_repository.update_inventory.return_value = mock_updated_product
    
    inventory_data = pydantic_models.InventoryUpdate(stock=25)
    
    result = await product_service.update_inventory(mock_request, "test_id_123", inventory_data)
    
    assert result.id == "test_id_123"
    assert result.stock == 25
    
    product_service.product_repository.update_inventory.assert_called_once_with("test_id_123", 25)

@pytest.mark.asyncio
async def test_update_inventory_not_found(product_service, mock_request):
    product_service.product_repository.update_inventory.return_value = None
    
    inventory_data = pydantic_models.InventoryUpdate(stock=25)
    
    result = await product_service.update_inventory(mock_request, "non_existent_id", inventory_data)
    
    assert isinstance(result, JSONResponse)
    assert result.status_code == 404
    assert "Not Found" in result.body.decode()

@pytest.mark.asyncio
async def test_backward_compatibility_empty_image_fields(product_service, mock_request):
    product_without_image_fields = ProductDB(
        id="old_product",
        name="Old Product",
        price=50.0,
        stock=5,
        description="Old product without image fields"
    )
    
    product_service.product_repository.get_product_by_id.return_value = product_without_image_fields
    
    result = await product_service.get_product(mock_request, "old_product")
    
    assert hasattr(result, 'id')
    assert result.id == "old_product"
    assert result.images == []
    assert result.primary_image_id is None

@pytest.mark.asyncio
async def test_product_response_structure(product_service, mock_request, sample_product_db, sample_image_data):
    product_service.product_repository.get_product_by_id.return_value = sample_product_db
    product_service.image_repository.get_image_by_id.return_value = sample_image_data
    
    result = await product_service.get_product(mock_request, "test_id_123")
    
    assert hasattr(result, 'id')
    assert hasattr(result, 'name')
    assert hasattr(result, 'price')
    assert hasattr(result, 'stock')
    assert hasattr(result, 'description')
    assert hasattr(result, 'images')
    assert hasattr(result, 'primary_image_id')
    
    assert isinstance(result.images, list)
    if result.images:
        image = result.images[0]
        assert hasattr(image, 'id')
        assert hasattr(image, 'url')
        assert hasattr(image, 'is_primary')
        assert hasattr(image, 'width')
        assert hasattr(image, 'height')

if __name__ == "__main__":
    pytest.main([__file__, "-v"])
