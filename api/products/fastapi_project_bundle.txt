================================================================================
FASTAPI PROJECT BUNDLE
Generated: 2025-11-23 22:28:13
Project Root: D:\codes\remote\New Stages\clean-architecture\api\products
================================================================================

PROJECT STRUCTURE:
----------------------------------------
products/
  bundle.py
  Dockerfile
  requirements.txt
  app/
    main.py
    pytest.ini
    requirements.txt
    __init__.py
    database/
      models.py
      __init__.py
    decorators/
      product_routes_decorators.py
      __init__.py
    routes/
      product_routes.py
      __init__.py
    services/
      product_helpers.py
      product_services.py
      __init__.py
    tests/
      test_product_contract.py
      test_product_services.py
      __init__.py

FILE CONTENTS:
================================================================================

FILE: bundle.py
------------------------------------------------------------
#!/usr/bin/env python3
"""
FastAPI Project Bundler
Creates a single text file containing the entire project structure and code.
"""

import os
import pathlib
import argparse
from datetime import datetime
import fnmatch

class FastAPIBundler:
    def __init__(self, project_root=".", output_file="fastapi_project_bundle.txt"):
        self.project_root = pathlib.Path(project_root).resolve()
        self.output_file = pathlib.Path(output_file)
        self.ignored_patterns = [
            '__pycache__',
            '*.pyc',
            '.git',
            '.vscode',
            '.idea',
            'node_modules',
            'venv',
            'env',
            '.env',
            '*.log',
            'dist',
            'build',
            '*.egg-info',
            '.pytest_cache',
            '*.sqlite',
            '*.db',
            'coverage',
            '.coverage'
        ]
        
    def should_ignore(self, path):
        """Check if a path should be ignored based on patterns."""
        path_str = str(path)
        for pattern in self.ignored_patterns:
            if fnmatch.fnmatch(path.name, pattern) or pattern in path_str:
                return True
        return False
    
    def get_file_content(self, file_path):
        """Read file content, handling binary files gracefully."""
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                return f.read()
        except UnicodeDecodeError:
            return f"[BINARY FILE - {file_path}]\n"
        except Exception as e:
            return f"[ERROR READING FILE {file_path}: {str(e)}]\n"
    
    def generate_bundle(self):
        """Generate the project bundle."""
        bundle_content = []
        
        # Header
        bundle_content.append("=" * 80)
        bundle_content.append(f"FASTAPI PROJECT BUNDLE")
        bundle_content.append(f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        bundle_content.append(f"Project Root: {self.project_root}")
        bundle_content.append("=" * 80)
        bundle_content.append("")
        
        # Project structure
        bundle_content.append("PROJECT STRUCTURE:")
        bundle_content.append("-" * 40)
        
        for root, dirs, files in os.walk(self.project_root):
            root_path = pathlib.Path(root)
            
            # Filter ignored directories
            dirs[:] = [d for d in dirs if not self.should_ignore(root_path / d)]
            
            # Calculate relative path for display
            try:
                rel_path = root_path.relative_to(self.project_root)
            except ValueError:
                rel_path = root_path
            
            # Add directory to structure
            indent = "  " * (len(rel_path.parts) if rel_path != pathlib.Path('.') else 0)
            bundle_content.append(f"{indent}{root_path.name}/")
            
            # Add files in this directory
            for file in files:
                file_path = root_path / file
                if not self.should_ignore(file_path):
                    file_indent = "  " * (len(rel_path.parts) + 1 if rel_path != pathlib.Path('.') else 1)
                    bundle_content.append(f"{file_indent}{file}")
        
        bundle_content.append("")
        bundle_content.append("FILE CONTENTS:")
        bundle_content.append("=" * 80)
        bundle_content.append("")
        
        # File contents
        for root, dirs, files in os.walk(self.project_root):
            root_path = pathlib.Path(root)
            
            # Filter ignored directories
            dirs[:] = [d for d in dirs if not self.should_ignore(root_path / d)]
            
            for file in files:
                file_path = root_path / file
                
                if not self.should_ignore(file_path):
                    try:
                        rel_path = file_path.relative_to(self.project_root)
                    except ValueError:
                        rel_path = file_path
                    
                    # Add file header
                    bundle_content.append(f"FILE: {rel_path}")
                    bundle_content.append("-" * 60)
                    
                    # Add file content
                    content = self.get_file_content(file_path)
                    bundle_content.append(content)
                    
                    # Add separator between files
                    bundle_content.append("\n" + "=" * 80 + "\n")
        
        return "\n".join(bundle_content)
    
    def save_bundle(self, content):
        """Save the bundle content to file."""
        with open(self.output_file, 'w', encoding='utf-8') as f:
            f.write(content)
        print(f"Bundle saved to: {self.output_file}")
        print(f"Total size: {len(content)} characters")

def main():
    parser = argparse.ArgumentParser(description='Bundle FastAPI project into a single text file')
    parser.add_argument('--root', '-r', default='.', 
                       help='Project root directory (default: current directory)')
    parser.add_argument('--output', '-o', default='fastapi_project_bundle.txt',
                       help='Output file name (default: fastapi_project_bundle.txt)')
    parser.add_argument('--ignore', '-i', nargs='*', 
                       help='Additional patterns to ignore')
    
    args = parser.parse_args()
    
    # Create bundler
    bundler = FastAPIBundler(project_root=args.root, output_file=args.output)
    
    # Add custom ignore patterns
    if args.ignore:
        bundler.ignored_patterns.extend(args.ignore)
    
    # Generate and save bundle
    print(f"Bundling FastAPI project from: {bundler.project_root}")
    print("This may take a moment...")
    
    bundle_content = bundler.generate_bundle()
    bundler.save_bundle(bundle_content)
    
    # Show some statistics
    lines = bundle_content.split('\n')
    files_count = bundle_content.count('FILE: ')
    print(f"Bundle contains {files_count} files and {len(lines)} lines")

if __name__ == "__main__":
    main()

================================================================================

FILE: Dockerfile
------------------------------------------------------------


================================================================================

FILE: requirements.txt
------------------------------------------------------------
fastapi
PyJWT
bcrypt
pytest
pytest-asyncio
pytest-cov
pydantic[email]
uvicorn
httpx==0.27.2

================================================================================

FILE: app\main.py
------------------------------------------------------------
from fastapi import FastAPI, Request
from fastapi.responses import JSONResponse
from fastapi.middleware.cors import CORSMiddleware
import logging
import uvicorn
from contextlib import asynccontextmanager
import os
from dotenv import load_dotenv

# Load environment variables
load_dotenv()

from routes.product_routes import router as product_router

# Environment variables with defaults
HOST = os.getenv('HOST', '0.0.0.0')
PORT = int(os.getenv('PORT', '8001'))
RELOAD = os.getenv('RELOAD', 'True').lower() == 'true'
LOG_LEVEL = os.getenv('LOG_LEVEL', 'info')
ENVIRONMENT = os.getenv('ENVIRONMENT', 'development')
CORS_ORIGINS = os.getenv('CORS_ORIGINS', 'http://localhost:3000,http://127.0.0.1:3000')
LOG_FILE = os.getenv('LOG_FILE', 'product_service.log')

ALLOWED_ORIGINS = [origin.strip() for origin in CORS_ORIGINS.split(',')]

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler(LOG_FILE)
    ]
)

logger = logging.getLogger(__name__)

@asynccontextmanager
async def lifespan(app: FastAPI):
    logger.info("Starting Product Service...")
    logger.info(f"Environment: {ENVIRONMENT}")
    logger.info(f"Host: {HOST}, Port: {PORT}")
    
    yield
    
    logger.info("Shutting down Product Service...")

app = FastAPI(
    title="Ecommerce API - Product Service",
    description="Product catalog microservice for Ecommerce API",
    version="1.0.0",
    docs_url="/docs",
    redoc_url="/redoc",
    openapi_url="/openapi.json",
    lifespan=lifespan
)

app.add_middleware(
    CORSMiddleware,
    allow_origins=ALLOWED_ORIGINS,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

@app.exception_handler(Exception)
async def global_exception_handler(request: Request, exc: Exception):
    logger.error(f"Global exception handler: {str(exc)}", exc_info=True)
    return JSONResponse(
        status_code=500,
        content={
            "type": "https://example.com/errors/internal",
            "title": "Internal Server Error",
            "status": 500,
            "detail": "An unexpected error occurred",
            "instance": str(request.url)
        },
        media_type="application/problem+json"
    )

@app.get("/health", tags=["Health"])
async def health_check():
    return {
        "status": "healthy",
        "service": "product",
        "timestamp": "2024-01-01T00:00:00Z",
        "environment": ENVIRONMENT
    }

@app.get("/", tags=["Root"])
async def root():
    return {
        "message": "Ecommerce Product Service",
        "version": "1.0.0",
        "environment": ENVIRONMENT,
        "docs": "/docs",
        "health": "/health"
    }

app.include_router(product_router, prefix="/api")

if __name__ == "__main__":
    uvicorn.run(
        "main:app",
        host=HOST,
        port=PORT,
        reload=RELOAD,
        log_level=LOG_LEVEL
    )

================================================================================

FILE: app\pytest.ini
------------------------------------------------------------
[pytest]
pythonpath = 
    ./
testpaths = ./tests
python_files = test_*.py
python_classes = Test*
python_functions = test_*
addopts = 
    -v
    --tb=short
    --strict-markers
    --strict-config
    --disable-warnings
markers =
    slow: marks tests as slow (deselect with '-m "not slow"')
    integration: marks tests as integration tests
    unit: marks tests as unit tests


================================================================================

FILE: app\requirements.txt
------------------------------------------------------------
fastapi==0.104.1
uvicorn[standard]==0.24.0
pydantic==2.5.0
pytest==7.4.3
pytest-asyncio==0.21.1
httpx==0.25.2
python-dotenv==1.0.0

================================================================================

FILE: app\__init__.py
------------------------------------------------------------


================================================================================

FILE: app\database\models.py
------------------------------------------------------------
from pydantic import BaseModel, Field, field_validator, ConfigDict
from typing import Optional, List
from datetime import datetime


class ProductRequest(BaseModel):
    name: str = Field(..., min_length=1, max_length=255, description="Product name is required")
    price: float = Field(..., gt=0, description="Price must be greater than 0")
    stock: int = Field(..., ge=0, description="Stock cannot be negative")
    description: Optional[str] = Field(None, max_length=1000, description="Description cannot exceed 1000 characters")

    @field_validator('name')
    def name_not_empty(cls, v):
        if not v or not v.strip():
            raise ValueError('Product name cannot be empty')
        return v.strip()


class ProductPatch(BaseModel):
    name: Optional[str] = Field(None, min_length=1, max_length=255)
    price: Optional[float] = Field(None, gt=0)
    stock: Optional[int] = Field(None, ge=0)
    description: Optional[str] = Field(None, max_length=1000)

    @field_validator('*', mode='before')
    def empty_string_to_none(cls, v):
        if v == "":
            return None
        return v


class ProductResponse(BaseModel):
    id: str
    name: str
    price: float
    stock: int
    description: Optional[str]

    model_config = ConfigDict(from_attributes=True)


class ProductList(BaseModel):
    items: List[ProductResponse]
    total: int
    page: int
    page_size: int


class InventoryUpdate(BaseModel):
    stock: int = Field(..., ge=0, description="Stock cannot be negative")


class ProductQueryParams(BaseModel):
    page: int = Field(1, ge=1, description="Page number must be positive")
    page_size: int = Field(20, ge=1, le=100, description="Page size must be between 1 and 100")
    q: Optional[str] = Field(None, description="Search query")


class InventoryResponse(BaseModel):
    id: str
    stock: int


class ErrorResponse(BaseModel):
    type: str
    title: str
    status: int
    detail: str
    instance: Optional[str] = None

================================================================================

FILE: app\database\__init__.py
------------------------------------------------------------


================================================================================

FILE: app\decorators\product_routes_decorators.py
------------------------------------------------------------
from functools import wraps
from fastapi import Request, Depends, HTTPException, status
from typing import Callable, Any
from services.product_services import ProductService

class ProductErrorDecorators:
    
    @staticmethod
    def handle_create_errors(func: Callable) -> Callable:
        @wraps(func)
        async def wrapper(
            request: Request,
            product_data: Any,
            product_service: ProductService = Depends(),
        ) -> Any:
            try:
                return await func(request, product_data, product_service)
            except Exception as e:
                return ProductErrorDecorators._handle_create_exception(e, request)
        return wrapper
    
    @staticmethod
    def handle_get_errors(func: Callable) -> Callable:
        @wraps(func)
        async def wrapper(
            request: Request,
            product_id: str,
            product_service: ProductService = Depends(),
        ) -> Any:
            try:
                return await func(request, product_id, product_service)
            except Exception as e:
                return ProductErrorDecorators._handle_get_exception(e, request)
        return wrapper
    
    @staticmethod
    def handle_list_errors(func: Callable) -> Callable:
        @wraps(func)
        async def wrapper(
            request: Request,
            product_service: ProductService = Depends(),
            page: int = 1,
            page_size: int = 20,
            q: str = None,
        ) -> Any:
            try:
                return await func(request, product_service, page, page_size, q)
            except Exception as e:
                return ProductErrorDecorators._handle_list_exception(e, request)
        return wrapper
    
    @staticmethod
    def handle_patch_errors(func: Callable) -> Callable:
        @wraps(func)
        async def wrapper(
            request: Request,
            product_id: str,
            patch_data: Any,
            product_service: ProductService = Depends(),
        ) -> Any:
            try:
                return await func(request, product_id, patch_data, product_service)
            except Exception as e:
                return ProductErrorDecorators._handle_update_exception(e, request)  # Can reuse the same exception handler
        return wrapper
    
    @staticmethod
    def handle_update_errors(func: Callable) -> Callable:
        @wraps(func)
        async def wrapper(
            request: Request,
            product_id: str,
            update_data: Any,
            product_service: ProductService = Depends(),
        ) -> Any:
            try:
                return await func(request, product_id, update_data, product_service)
            except Exception as e:
                return ProductErrorDecorators._handle_update_exception(e, request)
        return wrapper
    
    @staticmethod
    def handle_delete_errors(func: Callable) -> Callable:
        @wraps(func)
        async def wrapper(
            request: Request,
            product_id: str,
            product_service: ProductService = Depends(),
        ) -> Any:
            try:
                return await func(request, product_id, product_service)
            except Exception as e:
                return ProductErrorDecorators._handle_delete_exception(e, request)
        return wrapper
    
    @staticmethod
    def handle_inventory_errors(func: Callable) -> Callable:
        @wraps(func)
        async def wrapper(
            request: Request,
            product_id: str,
            inventory_data: Any,
            product_service: ProductService = Depends(),
        ) -> Any:
            try:
                return await func(request, product_id, inventory_data, product_service)
            except Exception as e:
                return ProductErrorDecorators._handle_inventory_exception(e, request)
        return wrapper
    
    @staticmethod
    def _handle_create_exception(error: Exception, request: Request) -> Any:
        error_str = str(error).lower()
        
        if "duplicate" in error_str or "already exists" in error_str:
            raise HTTPException(
                status_code=status.HTTP_409_CONFLICT,
                detail="Product already exists"
            )
        elif "validation" in error_str or "invalid" in error_str:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=str(error)
            )
        else:
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail="Product creation failed"
            )
    
    @staticmethod
    def _handle_get_exception(error: Exception, request: Request) -> Any:
        error_str = str(error).lower()
        
        if "not found" in error_str:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Product not found"
            )
        elif "validation" in error_str or "invalid" in error_str:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=str(error)
            )
        else:
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail="Product retrieval failed"
            )
    
    @staticmethod
    def _handle_list_exception(error: Exception, request: Request) -> Any:
        error_str = str(error).lower()
        
        if "validation" in error_str:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=str(error)
            )
        else:
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail="Products listing failed"
            )
    
    @staticmethod
    def _handle_update_exception(error: Exception, request: Request) -> Any:
        error_str = str(error).lower()
        
        if "not found" in error_str:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Product not found"
            )
        elif "validation" in error_str or "invalid" in error_str:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=str(error)
            )
        else:
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail="Product update failed"
            )
    
    @staticmethod
    def _handle_delete_exception(error: Exception, request: Request) -> Any:
        error_str = str(error).lower()
        
        if "not found" in error_str:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Product not found"
            )
        elif "validation" in error_str or "invalid" in error_str:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=str(error)
            )
        else:
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail="Product deletion failed"
            )
    
    @staticmethod
    def _handle_inventory_exception(error: Exception, request: Request) -> Any:
        error_str = str(error).lower()
        
        if "not found" in error_str:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Product not found"
            )
        elif "validation" in error_str or "invalid" in error_str:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=str(error)
            )
        else:
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail="Inventory update failed"
            )

================================================================================

FILE: app\decorators\__init__.py
------------------------------------------------------------


================================================================================

FILE: app\routes\product_routes.py
------------------------------------------------------------
import logging
import os
from fastapi import APIRouter, Request, Depends, Query
from services.product_services import ProductService
from database import models
from decorators.product_routes_decorators import ProductErrorDecorators

logger = logging.getLogger(__name__)

router = APIRouter(prefix='/products', tags=['products'])

# Environment variables with defaults
DEFAULT_PAGE_SIZE = int(os.getenv('DEFAULT_PAGE_SIZE', '20'))
MAX_PAGE_SIZE = int(os.getenv('MAX_PAGE_SIZE', '100'))

# Dependency injection functions
def get_product_service() -> ProductService:
    return ProductService(logger=logger)

@router.post(
    '',
    response_model=models.ProductResponse,
    status_code=201,
    summary="Create product"
)
@ProductErrorDecorators.handle_create_errors
async def create_product(
    request: Request,
    product_data: models.ProductRequest,
    product_service: ProductService = Depends(get_product_service),
) -> models.ProductResponse:
    return await product_service.create_product(request, product_data)

@router.get(
    '',
    response_model=models.ProductList,
    summary="List products (supports paging & filtering)"
)
@ProductErrorDecorators.handle_list_errors
async def list_products(
    request: Request,
    product_service: ProductService = Depends(get_product_service),
    page: int = Query(1, ge=1, description="Page number"),
    page_size: int = Query(DEFAULT_PAGE_SIZE, ge=1, le=MAX_PAGE_SIZE, description="Page size"),
    q: str = Query(None, description="Search query"),
) -> models.ProductList:
    query_params = models.ProductQueryParams(
        page=page,
        page_size=page_size,
        q=q
    )
    return await product_service.list_products(request, query_params)

@router.get(
    '/{product_id}',
    response_model=models.ProductResponse,
    summary="Get product details"
)
@ProductErrorDecorators.handle_get_errors
async def get_product(
    request: Request,
    product_id: str,
    product_service: ProductService = Depends(get_product_service),
) -> models.ProductResponse:
    return await product_service.get_product(request, product_id)

@router.put(
    '/{product_id}',
    response_model=models.ProductResponse,
    summary="Replace product (full update)"
)
@ProductErrorDecorators.handle_update_errors
async def update_product(
    request: Request,
    product_id: str,
    update_data: models.ProductRequest,
    product_service: ProductService = Depends(get_product_service),
) -> models.ProductResponse:
    return await product_service.update_product(request, product_id, update_data)

@router.patch(
    '/{product_id}',
    response_model=models.ProductResponse,
    summary="Partially update product"
)
@ProductErrorDecorators.handle_patch_errors
async def patch_product(
    request: Request,
    product_id: str,
    patch_data: models.ProductPatch,
    product_service: ProductService = Depends(get_product_service),
) -> models.ProductResponse:
    return await product_service.patch_product(request, product_id, patch_data)

@router.delete(
    '/{product_id}',
    status_code=204,
    summary="Delete product"
)
@ProductErrorDecorators.handle_delete_errors
async def delete_product(
    request: Request,
    product_id: str,
    product_service: ProductService = Depends(get_product_service),
) -> None:
    return await product_service.delete_product(request, product_id)


@router.patch(
    '/{product_id}/inventory',
    response_model=models.InventoryResponse,
    summary="Update product stock"
)
@ProductErrorDecorators.handle_inventory_errors
async def update_inventory(
    request: Request,
    product_id: str,
    inventory_data: models.InventoryUpdate,
    product_service: ProductService = Depends(get_product_service),
):
    return await product_service.update_inventory(request, product_id, inventory_data)

================================================================================

FILE: app\routes\__init__.py
------------------------------------------------------------


================================================================================

FILE: app\services\product_helpers.py
------------------------------------------------------------
from fastapi.responses import JSONResponse

def create_problem_response(
    status_code: int,
    error_type: str,
    title: str,
    detail: str,
    instance: str
) -> JSONResponse:
    problem_details = {
        "type": f"https://example.com/errors/{error_type}",
        "title": title,
        "status": status_code,
        "detail": detail,
        "instance": instance
    }
    return JSONResponse(
        status_code=status_code,
        content=problem_details,
        media_type="application/problem+json"
    )


================================================================================

FILE: app\services\product_services.py
------------------------------------------------------------
from .product_helpers import create_problem_response
from fastapi import Request
from fastapi.responses import JSONResponse
from database import models
from datetime import datetime

class ProductService:
    def __init__(self, logger):
        self.logger = logger
        # Mock data storage
        self.products = {}
        self.next_id = 1

    async def create_product(
        self,
        request: Request,
        product_data: models.ProductRequest
    ):
        self.logger.info(f"Product creation attempt: {product_data.name}")
        
        for product in self.products.values():
            if product['name'].lower() == product_data.name.lower():
                return create_problem_response(
                    status_code=409,
                    error_type="conflict",
                    title="Conflict",
                    detail="Product with this name already exists",
                    instance=str(request.url)
                )
        
        # Create product
        product_id = f"prod_{self.next_id}"
        
        product = models.ProductResponse(
            id=product_id,
            name=product_data.name,
            price=product_data.price,
            stock=product_data.stock,
            description=product_data.description
        )
        
        # Store in mock database
        self.products[product_id] = {
            'id': product_id,
            'name': product_data.name,
            'price': product_data.price,
            'stock': product_data.stock,
            'description': product_data.description,
            'created_at': datetime.now(),
            'updated_at': datetime.now()
        }
        self.next_id += 1
        
        self.logger.info(f"Product created successfully: {product_id}")
        
        response = JSONResponse(
            status_code=201,
            content=product.model_dump(),
            headers={"Location": f"/api/products/{product_id}"}
        )
        return response

    async def get_product(
        self,
        request: Request,
        product_id: str
    ):
        self.logger.info(f"Product retrieval attempt: {product_id}")
        
        product_data = self.products.get(product_id)
        
        if not product_data:
            return create_problem_response(
                status_code=404,
                error_type="not-found",
                title="Not Found",
                detail="Product not found",
                instance=str(request.url)
            )
        
        product = models.ProductResponse(**product_data)
        
        self.logger.info(f"Product retrieved successfully: {product_id}")
        return product

    async def list_products(
        self,
        request: Request,
        query_params: models.ProductQueryParams
    ):
        self.logger.info(f"Products listing attempt - Page: {query_params.page}, Size: {query_params.page_size}")
        
        # Mock implementation
        all_products = list(self.products.values())
        
        if query_params.q:
            search_term = query_params.q.lower()
            all_products = [
                p for p in all_products 
                if search_term in p['name'].lower() or 
                   (p['description'] and search_term in p['description'].lower())
            ]
        
        start_idx = (query_params.page - 1) * query_params.page_size
        end_idx = start_idx + query_params.page_size
        paginated_products = all_products[start_idx:end_idx]
        
        items = [models.ProductResponse(**product) for product in paginated_products]
        
        product_list = models.ProductList(
            items=items,
            total=len(all_products),
            page=query_params.page,
            page_size=query_params.page_size
        )
        
        self.logger.info(f"Products listed successfully - Found: {len(all_products)}")
        return product_list

    async def update_product(
        self,
        request: Request,
        product_id: str,
        update_data: models.ProductRequest
    ):
        self.logger.info(f"Product update attempt: {product_id}")
        
        product_data = self.products.get(product_id)
        
        if not product_data:
            return create_problem_response(
                status_code=404,
                error_type="not-found",
                title="Not Found",
                detail="Product not found",
                instance=str(request.url)
            )
        
        for pid, product in self.products.items():
            if pid != product_id and product['name'].lower() == update_data.name.lower():
                return create_problem_response(
                    status_code=409,
                    error_type="conflict",
                    title="Conflict",
                    detail="Product with this name already exists",
                    instance=str(request.url)
                )
        
        # Update product
        updated_product = models.ProductResponse(
            id=product_id,
            name=update_data.name,
            price=update_data.price,
            stock=update_data.stock,
            description=update_data.description
        )
        
        self.products[product_id] = {
            **self.products[product_id],
            'name': update_data.name,
            'price': update_data.price,
            'stock': update_data.stock,
            'description': update_data.description,
            'updated_at': datetime.now()
        }
        
        self.logger.info(f"Product updated successfully: {product_id}")
        return updated_product

    async def patch_product(
        self,
        request: Request,
        product_id: str,
        patch_data: models.ProductPatch
    ):
        self.logger.info(f"Product patch attempt: {product_id}")
        
        product_data = self.products.get(product_id)
        
        if not product_data:
            return create_problem_response(
                status_code=404,
                error_type="not-found",
                title="Not Found",
                detail="Product not found",
                instance=str(request.url)
            )
        
        # Apply partial updates
        update_dict = patch_data.model_dump(exclude_unset=True)
        
        if 'name' in update_dict:
            for pid, product in self.products.items():
                if pid != product_id and product['name'].lower() == update_dict['name'].lower():
                    return create_problem_response(
                        status_code=409,
                        error_type="conflict",
                        title="Conflict",
                        detail="Product with this name already exists",
                        instance=str(request.url)
                    )
        
        # Merge updates with existing data
        merged_data = {**product_data, **update_dict, 'updated_at': datetime.now()}
        
        updated_product = models.ProductResponse(**merged_data)
        self.products[product_id] = merged_data
        
        self.logger.info(f"Product patched successfully: {product_id}")
        return updated_product

    async def delete_product(
        self,
        request: Request,
        product_id: str
    ):
        self.logger.info(f"Product deletion attempt: {product_id}")
        
        if product_id not in self.products:
            return create_problem_response(
                status_code=404,
                error_type="not-found",
                title="Not Found",
                detail="Product not found",
                instance=str(request.url)
            )
        
        del self.products[product_id]
        
        self.logger.info(f"Product deleted successfully: {product_id}")
        return None

    async def update_inventory(
        self,
        request: Request,
        product_id: str,
        inventory_data: models.InventoryUpdate
    ):
        self.logger.info(f"Inventory update attempt: {product_id}")
        
        product_data = self.products.get(product_id)
        
        if not product_data:
            return create_problem_response(
                status_code=404,
                error_type="not-found",
                title="Not Found",
                detail="Product not found",
                instance=str(request.url)
            )
        
        # Update stock
        self.products[product_id] = {
            **self.products[product_id],
            'stock': inventory_data.stock,
            'updated_at': datetime.now()
        }
        
        response_data = models.InventoryResponse(
            id=product_id,
            stock=inventory_data.stock
        )
        
        self.logger.info(f"Inventory updated successfully: {product_id} -> Stock: {inventory_data.stock}")
        return response_data

================================================================================

FILE: app\services\__init__.py
------------------------------------------------------------


================================================================================

FILE: app\tests\test_product_contract.py
------------------------------------------------------------
import pytest
import pytest_asyncio
from httpx import ASGITransport, AsyncClient
from main import app


class TestProductAPIContract:    
    @pytest_asyncio.fixture
    async def client(self):
        async with AsyncClient(transport=ASGITransport(app=app), base_url="http://test") as client:
            yield client

    @pytest.mark.asyncio
    async def test_health_endpoint(self, client):
        response = await client.get("/health")
        
        assert response.status_code == 200
        data = response.json()
        assert "status" in data
        assert "service" in data
        assert "timestamp" in data
        assert data["service"] == "product"

    @pytest.mark.asyncio
    async def test_root_endpoint(self, client):
        response = await client.get("/")
        
        assert response.status_code == 200
        data = response.json()
        assert "message" in data
        assert "version" in data
        assert "docs" in data
        assert "health" in data

    @pytest.mark.asyncio
    async def test_create_product_contract(self, client):
        product_data = {
            "name": "Test Product",
            "price": 29.99,
            "stock": 100,
            "description": "Test product description"
        }
        
        response = await client.post("/api/products", json=product_data)
        
        assert response.status_code in [201, 409]
        
        if response.status_code == 201:
            data = response.json()
            assert "id" in data
            assert "name" in data
            assert "price" in data
            assert "stock" in data
            assert "description" in data
            assert data["name"] == product_data["name"]
            assert data["price"] == product_data["price"]
            assert data["stock"] == product_data["stock"]
            
            assert "Location" in response.headers
            assert "/api/products/" in response.headers["Location"]

    @pytest.mark.asyncio
    async def test_create_product_validation_contract(self, client):
        invalid_data = {
            "name": "",
            "price": -10.00,
            "stock": -5
        }
        
        response = await client.post("/api/products", json=invalid_data)
        
        assert response.status_code == 422

    @pytest.mark.asyncio
    async def test_list_products_contract(self, client):
        # First create a product to ensure there's data
        product_data = {
            "name": "Test Product for List",
            "price": 39.99,
            "stock": 50,
            "description": "Test product for listing"
        }
        
        create_response = await client.post("/api/products", json=product_data)
        
        response = await client.get("/api/products")
        assert response.status_code == 200
        
        if response.status_code == 200:
            data = response.json()
            assert "items" in data
            assert "total" in data
            assert "page" in data
            assert "page_size" in data
            assert isinstance(data["items"], list)

    @pytest.mark.asyncio
    async def test_list_products_pagination_contract(self, client):
        # First create some products
        for i in range(3):
            product_data = {
                "name": f"Test Product {i}",
                "price": 10.99 + i,
                "stock": 10 * (i + 1),
                "description": f"Test product {i}"
            }
            await client.post("/api/products", json=product_data)
        
        response = await client.get("/api/products?page=2&page_size=5")
        assert response.status_code == 200
        
        if response.status_code == 200:
            data = response.json()
            assert data["page"] == 2
            assert data["page_size"] == 5
        
    @pytest.mark.asyncio
    async def test_get_product_contract(self, client):
        product_data = {
            "name": "Test Product for Get",
            "price": 39.99,
            "stock": 50,
            "description": "Test product for get operation"
        }
        
        create_response = await client.post("/api/products", json=product_data)
        
        if create_response.status_code == 201:
            product_id = create_response.json()["id"]
            
            response = await client.get(f"/api/products/{product_id}")
            
            print(f'responssss {response}')
            assert response.status_code in [200, 404]
            
            if response.status_code == 200:
                data = response.json()
                assert "id" in data
                assert "name" in data
                assert "price" in data
                assert "stock" in data

    @pytest.mark.asyncio
    async def test_get_product_not_found_contract(self, client):
        response = await client.get("/api/products/non_existent_id")
        
        assert response.status_code == 404

    @pytest.mark.asyncio
    async def test_update_product_contract(self, client):
        # First create a product to update
        product_data = {
            "name": "Test Product for Update",
            "price": 49.99,
            "stock": 75,
            "description": "Test product for update operation"
        }
        
        create_response = await client.post("/api/products", json=product_data)
        
        if create_response.status_code == 201:
            product_id = create_response.json()["id"]
            
            update_data = {
                "name": "Updated Product",
                "price": 59.99,
                "stock": 100,
                "description": "Updated description"
            }
            
            response = await client.put(f"/api/products/{product_id}", json=update_data)
            
            assert response.status_code in [200, 404]
            
            if response.status_code == 200:
                data = response.json()
                assert data["name"] == update_data["name"]
                assert data["price"] == update_data["price"]
                assert data["stock"] == update_data["stock"]

    @pytest.mark.asyncio
    async def test_patch_product_contract(self, client):
        # First create a product to patch
        product_data = {
            "name": "Test Product for Patch",
            "price": 69.99,
            "stock": 25,
            "description": "Test product for patch operation"
        }
        
        create_response = await client.post("/api/products", json=product_data)
        
        if create_response.status_code == 201:
            product_id = create_response.json()["id"]
            
            patch_data = {
                "stock": 50
            }
            
            response = await client.patch(f"/api/products/{product_id}", json=patch_data)
            
            assert response.status_code in [200, 404]
            
            if response.status_code == 200:
                data = response.json()
                assert data["stock"] == patch_data["stock"]

    @pytest.mark.asyncio
    async def test_delete_product_contract(self, client):
        # First create a product to delete
        product_data = {
            "name": "Test Product for Delete",
            "price": 79.99,
            "stock": 10,
            "description": "Test product for delete operation"
        }
        
        create_response = await client.post("/api/products", json=product_data)
        
        if create_response.status_code == 201:
            product_id = create_response.json()["id"]
            
            response = await client.delete(f"/api/products/{product_id}")
            
            assert response.status_code in [204, 404]

    @pytest.mark.asyncio
    async def test_update_inventory_contract(self, client):
        # First create a product to update inventory
        product_data = {
            "name": "Test Product for Inventory",
            "price": 89.99,
            "stock": 30,
            "description": "Test product for inventory operation"
        }
        
        create_response = await client.post("/api/products", json=product_data)
        
        if create_response.status_code == 201:
            product_id = create_response.json()["id"]
            
            inventory_data = {
                "stock": 60
            }
            
            response = await client.patch(f"/api/products/{product_id}/inventory", json=inventory_data)
            
            assert response.status_code in [200, 404]
            
            if response.status_code == 200:
                data = response.json()
                assert "id" in data
                assert "stock" in data
                assert data["stock"] == inventory_data["stock"]


class TestProductAPIErrorScenarios:
    
    @pytest_asyncio.fixture
    async def client(self):
        async with AsyncClient(transport=ASGITransport(app=app), base_url="http://test") as client:
            yield client

    @pytest.mark.asyncio
    async def test_malformed_json_contract(self, client):
        response = await client.post(
            "/api/products",
            content="{invalid json",
            headers={"Content-Type": "application/json"}
        )
        assert response.status_code == 422

    @pytest.mark.asyncio
    async def test_unsupported_media_type_contract(self, client):
        response = await client.post(
            "/api/products",
            content="name=Test",
            headers={"Content-Type": "application/x-www-form-urlencoded"}
        )
        assert response.status_code == 422

    @pytest.mark.asyncio
    async def test_method_not_allowed_contract(self, client):
        response = await client.put("/api/products")
        assert response.status_code == 405

    @pytest.mark.asyncio
    async def test_cors_headers_contract(self, client):
        response = await client.get("/health", headers={"Origin": "http://localhost:3000"})
        
        if "access-control-allow-origin" in response.headers:
            assert response.headers["access-control-allow-origin"] == "http://localhost:3000"


================================================================================

FILE: app\tests\test_product_services.py
------------------------------------------------------------
import pytest
import pytest_asyncio
from unittest.mock import Mock
from fastapi import Request
from fastapi.responses import JSONResponse
from fastapi.testclient import TestClient
from main import app
from services.product_services import ProductService
from database import models


class TestProductService:
    @pytest.fixture
    def client(self):
        return TestClient(app)

    @pytest_asyncio.fixture
    async def mock_logger(self):
        return Mock()

    @pytest_asyncio.fixture
    async def mock_request(self):
        request = Mock(spec=Request)
        request.url = "http://testserver/api/products"
        return request

    @pytest_asyncio.fixture
    async def product_service(self, mock_logger):
        return ProductService(logger=mock_logger)

    def test_client_initialization(self, client):
        response = client.get("/health")
        assert response.status_code == 200

    @pytest.mark.asyncio
    async def test_create_product_success(
        self, product_service, mock_request
    ):
        product_data = models.ProductRequest(
            name="Test Product",
            price=29.99,
            stock=100,
            description="Test description"
        )

        result = await product_service.create_product(
            mock_request, product_data
        )

        assert isinstance(result, JSONResponse)
        assert result.status_code == 201
        assert "Location" in result.headers
        assert "/api/products/prod_1" in result.headers["Location"]
        
        product_service.logger.info.assert_any_call("Product creation attempt: Test Product")
        product_service.logger.info.assert_any_call("Product created successfully: prod_1")

    @pytest.mark.asyncio
    async def test_create_product_duplicate(
        self, product_service, mock_request
    ):
        # Create first product
        product_data = models.ProductRequest(
            name="Duplicate Product",
            price=39.99,
            stock=50,
            description="First product"
        )
        await product_service.create_product(mock_request, product_data)

        # Try to create duplicate
        duplicate_data = models.ProductRequest(
            name="Duplicate Product",
            price=49.99,
            stock=25,
            description="Duplicate product"
        )

        result = await product_service.create_product(
            mock_request, duplicate_data
        )

        assert isinstance(result, JSONResponse)
        assert result.status_code == 409

    @pytest.mark.asyncio
    async def test_get_product_success(
        self, product_service, mock_request
    ):
        # First create a product
        product_data = models.ProductRequest(
            name="Test Product for Get",
            price=59.99,
            stock=75,
            description="Test product for get"
        )
        create_result = await product_service.create_product(mock_request, product_data)
        product_id = "prod_1"

        result = await product_service.get_product(
            mock_request, product_id
        )

        assert isinstance(result, models.ProductResponse)
        assert result.id == product_id
        assert result.name == "Test Product for Get"
        
        product_service.logger.info.assert_any_call(f"Product retrieval attempt: {product_id}")
        product_service.logger.info.assert_any_call(f"Product retrieved successfully: {product_id}")

    @pytest.mark.asyncio
    async def test_get_product_not_found(
        self, product_service, mock_request
    ):
        result = await product_service.get_product(
            mock_request, "non_existent_id"
        )

        assert isinstance(result, JSONResponse)
        assert result.status_code == 404

    @pytest.mark.asyncio
    async def test_list_products_success(
        self, product_service, mock_request
    ):
        # Create some test products
        for i in range(3):
            product_data = models.ProductRequest(
                name=f"Test Product {i}",
                price=10 + i + .99,
                stock=10 * (i + 1),
                description=f"Test product {i}"
            )
            await product_service.create_product(mock_request, product_data)

        query_params = models.ProductQueryParams(
            page=1,
            page_size=20
        )

        result = await product_service.list_products(
            mock_request, query_params
        )

        assert isinstance(result, models.ProductList)
        assert len(result.items) == 3
        assert result.total == 3
        assert result.page == 1
        assert result.page_size == 20

    @pytest.mark.asyncio
    async def test_list_products_with_search(
        self, product_service, mock_request
    ):
        # Create test products
        product_data1 = models.ProductRequest(
            name="Laptop Computer",
            price=999.99,
            stock=5,
            description="High-performance laptop"
        )
        product_data2 = models.ProductRequest(
            name="Wireless Mouse",
            price=29.99,
            stock=20,
            description="Ergonomic wireless mouse"
        )
        
        await product_service.create_product(mock_request, product_data1)
        await product_service.create_product(mock_request, product_data2)

        query_params = models.ProductQueryParams(
            page=1,
            page_size=20,
            q="laptop"
        )

        result = await product_service.list_products(
            mock_request, query_params
        )

        assert isinstance(result, models.ProductList)
        assert len(result.items) == 1
        assert "Laptop" in result.items[0].name

    @pytest.mark.asyncio
    async def test_update_product_success(
        self, product_service, mock_request
    ):
        # First create a product
        product_data = models.ProductRequest(
            name="Product to Update",
            price=79.99,
            stock=30,
            description="Original description"
        )
        await product_service.create_product(mock_request, product_data)
        product_id = "prod_1"

        update_data = models.ProductRequest(
            name="Updated Product",
            price=89.99,
            stock=40,
            description="Updated description"
        )

        result = await product_service.update_product(
            mock_request, product_id, update_data
        )

        assert isinstance(result, models.ProductResponse)
        assert result.name == "Updated Product"
        assert result.price == 89.99
        assert result.stock == 40
        
        product_service.logger.info.assert_any_call(f"Product update attempt: {product_id}")
        product_service.logger.info.assert_any_call(f"Product updated successfully: {product_id}")

    @pytest.mark.asyncio
    async def test_patch_product_success(
        self, product_service, mock_request
    ):
        # First create a product
        product_data = models.ProductRequest(
            name="Product to Patch",
            price=99.99,
            stock=15,
            description="Original description"
        )
        await product_service.create_product(mock_request, product_data)
        product_id = "prod_1"

        patch_data = models.ProductPatch(
            stock=25
        )

        result = await product_service.patch_product(
            mock_request, product_id, patch_data
        )

        assert isinstance(result, models.ProductResponse)
        assert result.stock == 25
        assert result.name == "Product to Patch"  # Should remain unchanged

    @pytest.mark.asyncio
    async def test_delete_product_success(
        self, product_service, mock_request
    ):
        # First create a product
        product_data = models.ProductRequest(
            name="Product to Delete",
            price=49.99,
            stock=10,
            description="To be deleted"
        )
        await product_service.create_product(mock_request, product_data)
        product_id = "prod_1"

        result = await product_service.delete_product(
            mock_request, product_id
        )

        assert result is None
        
        # Verify product is gone
        get_result = await product_service.get_product(mock_request, product_id)
        assert get_result.status_code == 404
        
        product_service.logger.info.assert_any_call(f"Product deletion attempt: {product_id}")
        product_service.logger.info.assert_any_call(f"Product deleted successfully: {product_id}")

    @pytest.mark.asyncio
    async def test_update_inventory_success(
        self, product_service, mock_request
    ):
        # First create a product
        product_data = models.ProductRequest(
            name="Product for Inventory",
            price=69.99,
            stock=20,
            description="Inventory test"
        )
        await product_service.create_product(mock_request, product_data)
        product_id = "prod_1"

        inventory_data = models.InventoryUpdate(
            stock=50
        )

        result = await product_service.update_inventory(
            mock_request, product_id, inventory_data
        )

        assert isinstance(result, models.InventoryResponse)  # Check for model, not dict
        assert result.id == product_id
        assert result.stock == 50
        
        product_service.logger.info.assert_any_call(f"Inventory update attempt: {product_id}")
        product_service.logger.info.assert_any_call(f"Inventory updated successfully: {product_id} -> Stock: 50")

    @pytest.mark.asyncio
    async def test_service_initialization(self, mock_logger):
        service = ProductService(logger=mock_logger)

        assert service.logger == mock_logger
        assert service.products == {}
        assert service.next_id == 1


================================================================================

FILE: app\tests\__init__.py
------------------------------------------------------------


================================================================================
